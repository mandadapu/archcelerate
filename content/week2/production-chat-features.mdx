# Production Chat Features

Build production-ready chat applications with persistence, authentication, and advanced features.

## Conversation Persistence

Store conversations across sessions for continuity and user value.

### Database Implementation

```typescript
// Creating a new conversation
async function createConversation(userId: string, firstMessage: string) {
  const supabase = createClient()

  // Create conversation
  const { data: conversation } = await supabase
    .from('conversations')
    .insert({
      user_id: userId,
      title: firstMessage.substring(0, 50) // First message as title
    })
    .select()
    .single()

  return conversation.id
}

// Adding messages to conversation
async function addMessage(
  conversationId: string,
  role: 'user' | 'assistant',
  content: string,
  tokens: number
) {
  const supabase = createClient()

  await supabase.from('messages').insert({
    conversation_id: conversationId,
    role,
    content,
    tokens
  })
}
```

### Loading Conversation History

```typescript
// Efficient message loading with pagination
async function loadConversation(conversationId: string, limit = 50) {
  const supabase = createClient()

  const { data: messages } = await supabase
    .from('messages')
    .select('role, content, created_at, tokens')
    .eq('conversation_id', conversationId)
    .order('created_at', { ascending: true })
    .limit(limit)

  return messages
}

// Load recent conversations list
async function getUserConversations(userId: string) {
  const supabase = createClient()

  const { data: conversations } = await supabase
    .from('conversations')
    .select('id, title, created_at, updated_at')
    .eq('user_id', userId)
    .order('updated_at', { descending: true })
    .limit(20)

  return conversations
}
```

## Authentication & Authorization

Secure your chat application with proper auth.

### Supabase Auth Integration

```typescript
// Check authentication in API route
export async function POST(request: Request) {
  const supabase = createClient()

  // Get authenticated user
  const { data: { user }, error } = await supabase.auth.getUser()

  if (error || !user) {
    return Response.json(
      { error: 'Unauthorized' },
      { status: 401 }
    )
  }

  // User is authenticated, proceed with request
  // user.id is available for database queries
}
```

### Row Level Security (RLS)

Enforce authorization at the database level:

```sql
-- Users can only access their own conversations
CREATE POLICY "Users can read own conversations"
  ON conversations
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create own conversations"
  ON conversations
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can only access messages in their conversations
CREATE POLICY "Users can read messages in own conversations"
  ON messages
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM conversations
      WHERE conversations.id = messages.conversation_id
      AND conversations.user_id = auth.uid()
    )
  );
```

**Benefits of RLS**:
- **Security by default**: Can't accidentally leak data
- **Simplified queries**: No need to filter by user_id
- **Performance**: Database-level enforcement

## Real-time Streaming

Implement streaming for better user experience.

### Server-Sent Events (SSE)

```typescript
// API route with streaming
export async function POST(request: Request) {
  const { messages } = await request.json()

  const stream = await anthropic.messages.stream({
    model: 'claude-3-5-sonnet-20241022',
    max_tokens: 1024,
    messages
  })

  const encoder = new TextEncoder()

  const readableStream = new ReadableStream({
    async start(controller) {
      try {
        for await (const event of stream) {
          if (event.type === 'content_block_delta') {
            const chunk = event.delta.text
            controller.enqueue(encoder.encode(`data: ${chunk}\n\n`))
          }
        }

        // Send completion event
        controller.enqueue(encoder.encode('data: [DONE]\n\n'))
        controller.close()

      } catch (error) {
        controller.error(error)
      }
    }
  })

  return new Response(readableStream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  })
}
```

### Client-side Streaming

```typescript
// React component with streaming
async function streamChat(message: string) {
  const response = await fetch('/api/chat/stream', {
    method: 'POST',
    body: JSON.stringify({ message })
  })

  const reader = response.body?.getReader()
  const decoder = new TextDecoder()

  let fullResponse = ''

  while (true) {
    const { done, value } = await reader!.read()

    if (done) break

    const chunk = decoder.decode(value)
    const lines = chunk.split('\n')

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = line.slice(6)

        if (data === '[DONE]') {
          return fullResponse
        }

        fullResponse += data
        // Update UI with partial response
        setMessages(prev => [
          ...prev.slice(0, -1),
          { role: 'assistant', content: fullResponse }
        ])
      }
    }
  }
}
```

## Error Handling & Recovery

Build resilient chat experiences.

### Graceful Degradation

```typescript
async function sendMessage(message: string) {
  try {
    // Try primary model
    return await callClaude(message)

  } catch (error) {
    if (error.type === 'rate_limit_error') {
      // Wait and retry
      await sleep(error.retryAfter * 1000)
      return await callClaude(message)
    }

    if (error.type === 'overloaded_error') {
      // Try fallback model
      console.warn('Claude overloaded, using fallback')
      return await callGPT35(message)
    }

    // Unrecoverable error
    throw new Error('Unable to process message')
  }
}
```

### User-Facing Error Messages

```typescript
function getUserFriendlyError(error: any) {
  const errorMessages = {
    rate_limit: 'Too many messages. Please wait a moment.',
    budget_exceeded: 'Monthly usage limit reached. Upgrade for more.',
    moderation: 'Message violates content policy.',
    network: 'Connection issue. Check your internet.',
    api_error: 'Service temporarily unavailable. Try again.'
  }

  return errorMessages[error.type] || 'Something went wrong.'
}
```

## Advanced Features

### Message Regeneration

```typescript
async function regenerateMessage(conversationId: string) {
  // Get all messages except last assistant message
  const messages = await getMessages(conversationId)
  const withoutLast = messages.slice(0, -1)

  // Delete last message
  await deleteMessage(messages[messages.length - 1].id)

  // Generate new response
  const newResponse = await generateResponse(withoutLast)

  return newResponse
}
```

### Message Editing

```typescript
async function editMessage(messageId: string, newContent: string) {
  // Delete all messages after edited message
  await deleteMessagesAfter(messageId)

  // Update the edited message
  await updateMessage(messageId, newContent)

  // Regenerate conversation from this point
  const messages = await getMessagesUpTo(messageId)
  return await generateResponse(messages)
}
```

### Export Conversations

```typescript
async function exportConversation(conversationId: string) {
  const messages = await getMessages(conversationId)

  // Format as markdown
  const markdown = messages.map(m =>
    `**${m.role}**: ${m.content}`
  ).join('\n\n')

  return markdown
}
```

## Performance Optimization

### Message Batching

```typescript
// Batch insert messages for better performance
async function saveMessages(messages: Message[]) {
  const supabase = createClient()

  await supabase.from('messages').insert(
    messages.map(m => ({
      conversation_id: m.conversationId,
      role: m.role,
      content: m.content,
      tokens: m.tokens
    }))
  )
}
```

### Caching Strategies

```typescript
// Cache user's recent conversations
const conversationCache = new Map<string, Conversation[]>()

async function getCachedConversations(userId: string) {
  if (conversationCache.has(userId)) {
    return conversationCache.get(userId)
  }

  const conversations = await loadConversations(userId)
  conversationCache.set(userId, conversations)

  // Invalidate after 5 minutes
  setTimeout(() => conversationCache.delete(userId), 5 * 60 * 1000)

  return conversations
}
```

## Key Takeaways

1. **Persistence is essential**: Users expect conversation history
2. **Secure by default**: Use RLS, authenticate properly
3. **Stream responses**: Dramatically better UX
4. **Handle errors gracefully**: Retry, fallback, inform users
5. **Optimize performance**: Batch operations, cache smartly
6. **Advanced features**: Regeneration, editing, export add value

## Next Steps

- Implement comprehensive governance
- Add monitoring and observability
- Deploy to production with proper infrastructure
