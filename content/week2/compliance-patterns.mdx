---
title: "Domain Compliance & Redaction"
description: "Engineer high-speed PII/PHI redaction pipelines and data residency patterns for regulated industries"
estimatedMinutes: 50
---

# Domain Compliance & Redaction: PII/PHI Protection

Build **high-speed redaction pipelines** that de-identify sensitive data before it reaches third-party LLM APIs‚Äîand design **Local-First inference patterns** to keep PII within your VPC.

> **Architect Perspective**: Compliance isn't about legal documents‚Äîit's about **engineering data flow** to ensure PII/PHI **never** leaves your control perimeter. Build redaction as **zero-latency middleware** (<5ms overhead) and design Local-First patterns to **technically prevent** data residency violations.

---

## üè• Real-World Challenge: The HIPAA-Compliant AI Gateway

**The Problem**: A telehealth startup wants to use frontier LLMs (Claude Opus, GPT-5) for medical diagnosis assistance. But sending raw patient data to third-party APIs violates HIPAA‚ÄîProtected Health Information (PHI) cannot leave the company's controlled environment without risking **$50,000+ fines per violation**.

**Business Constraints**:
- **Compliance**: Must meet HIPAA data residency requirements (PHI stays in US, within HIPAA-certified infrastructure)
- **Functionality**: Still needs advanced reasoning from frontier models (not available as on-premise deployments)
- **Performance**: Cannot add >10ms latency‚Äîdoctors expect instant responses
- **Auditability**: Must maintain complete audit trail for compliance inspections

**Architectural Solution: The Sovereign PII Redactor**

Deploy a **high-speed redaction pipeline** that sanitizes PHI before tokens leave your VPC:

```typescript
// Step 1: Regex-based fast path (<1ms) - catches obvious patterns
const fastRedacted = regexRedactor.sanitize(patientQuery)
// "Patient John Doe, SSN 123-45-6789, glucose 180 mg/dL"
// ‚Üí "Patient [REDACTED_NAME], SSN [REDACTED_SSN], glucose 180 mg/dL"

// Step 2: NER model (local, <3ms) - catches contextual PII
const fullRedacted = await nerRedactor.sanitize(fastRedacted)
// ‚Üí "Patient [REDACTED_NAME], SSN [REDACTED_SSN], glucose [REDACTED_LAB_VALUE]"

// Step 3: Cryptographic placeholders for reversibility
const tokenMap = generateReversibleTokens(fullRedacted)
// [REDACTED_NAME] ‚Üí crypto_placeholder_a7f3
// Store mapping in secure database (never sent to API)

// Step 4: Safe to send to external API
const response = await anthropic.messages.create({
  messages: [{ role: 'user', content: fullRedacted }]
})

// Step 5: Reverse redaction for display
const patientResponse = reverseRedaction(response.content, tokenMap)
```

**Production Implementation**:

**Layer 1: Pre-API Middleware** (adds 4.2ms latency)
- Regex redaction: 0.8ms (SSN, emails, phone numbers)
- NER model (local Transformer): 3.2ms (names, addresses, dates of birth)
- Token mapping: 0.2ms (generate crypto placeholders)

**Layer 2: Data Residency Enforcement**
- VPC-hosted redaction service (never leaves your AWS/Azure environment)
- Encrypted token maps stored in PostgreSQL (HIPAA-certified RDS)
- Audit log of every redaction (required for compliance)

**Layer 3: Reversibility for Display**
- Decryption happens client-side or in trusted VPC
- Original PHI never transmitted to external APIs
- Complete audit trail: what was redacted, when, by whom

**Production Impact**:
- **Compliance**: **100% HIPAA-compliant**‚ÄîPHI technically cannot reach third-party servers
- **Performance**: **4.2ms overhead** (within <10ms requirement)
- **Auditability**: Every request logged with redaction details for SOC 2 / HIPAA audits
- **Cost Avoidance**: **$1M+ in fines prevented** (average HIPAA violation settlement)
- **Functionality Preserved**: Still access Opus/GPT-5 for advanced medical reasoning

**Alternative: Local-First Architecture** (zero external data transmission)

For ultimate data residency:
```typescript
// Deploy Llama 3.3 (70B) on-premise with vLLM
const response = await localLLM.complete({
  model: 'llama-3.3-70b',
  prompt: rawPatientQuery  // No redaction needed‚Äîdata never leaves VPC
})
```

**Trade-off Matrix**:
| Architecture | Compliance | Cost | Quality | Latency |
|--------------|-----------|------|---------|---------|
| Redaction Gateway | ‚úÖ HIPAA | $200/mo | ‚úÖ Opus 4.5 | 4.2ms overhead |
| Local-First (Llama) | ‚úÖ HIPAA | $8K/mo GPU | ‚ö†Ô∏è Good but not Opus | 2-3s inference |

**When to Use Which**:
- **Redaction Gateway**: High-volume (>10K queries/day), need best-in-class reasoning, cost-sensitive
- **Local-First**: Ultra-sensitive data (psychiatric notes, genetic data), regulatory requirement for zero external transmission

**[üìö Dive Deeper: Implement the Redaction Pipeline](#high-speed-piiphi-redaction-regex--nlp-pipeline)**

Below, you'll find the complete production implementation with:
- Regex patterns for all common PII/PHI types
- NER model integration for contextual redaction
- Cryptographic token mapping for reversibility
- Audit logging for compliance

---

## The Compliance Engineering Problem

**Reality Check**: Sending raw user data to third-party LLM APIs is a compliance violation waiting to happen.

**Example Violations**:
```typescript
// ‚ùå HIPAA Violation
await anthropic.messages.create({
  messages: [{ role: 'user', content: 'Patient John Doe, SSN 123-45-6789, diagnosed with diabetes' }]
})
// PHI (SSN, diagnosis) sent to Anthropic servers (outside HIPAA control) ‚Üí $50K+ fine per violation

// ‚ùå GDPR Violation
await anthropic.messages.create({
  messages: [{ role: 'user', content: 'User email: user@example.com requested account deletion' }]
})
// PII (email) sent to US servers without explicit consent ‚Üí 4% of global revenue fine

// ‚úÖ Compliant
await anthropic.messages.create({
  messages: [{ role: 'user', content: 'Patient [REDACTED_ID], SSN [REDACTED_SSN], diagnosed with [REDACTED_CONDITION]' }]
})
// PHI redacted before API call ‚Üí compliant
```

**Cost of Compliance Violations**:
```typescript
// HIPAA Violations
- Tier 1 (unknowing): $100-$50,000 per violation
- Tier 4 (willful neglect): $50,000+ per violation
- Annual cap: $1.5M per violation type

// GDPR Violations
- Up to 4% of global annual revenue or ‚Ç¨20M (whichever is higher)
- Example: Meta fined ‚Ç¨1.2B for GDPR violations (2023)

// Engineering ROI
- Redaction pipeline: $30K one-time + $5K/year
- Local-First infrastructure: $50K one-time + $20K/year
- Total: $80K prevents $1M+ fines ‚Üí 12:1 ROI minimum
```

**Architectural Mandate**: **Never** send raw PII/PHI to external APIs. Build redaction as **mandatory middleware** and Local-First as **architectural isolation**.

---

## High-Speed PII/PHI Redaction: Regex + NLP Pipeline

**The Pattern**: Build a **two-phase** redaction pipeline that runs in <5ms‚Äîfast enough to be transparent to users.

### Phase 1: Regex-Based Fast Path (<1ms)

```typescript
interface RedactionPattern {
  type: 'PII' | 'PHI'
  name: string
  regex: RegExp
  replacement: string
  severity: 'critical' | 'high' | 'medium'
}

const REDACTION_PATTERNS: RedactionPattern[] = [
  // PII Patterns
  {
    type: 'PII',
    name: 'SSN',
    regex: /\b\d{3}-\d{2}-\d{4}\b/g,
    replacement: '[REDACTED_SSN]',
    severity: 'critical'
  },
  {
    type: 'PII',
    name: 'Credit Card',
    regex: /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g,
    replacement: '[REDACTED_CC]',
    severity: 'critical'
  },
  {
    type: 'PII',
    name: 'Email',
    regex: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
    replacement: '[REDACTED_EMAIL]',
    severity: 'high'
  },
  {
    type: 'PII',
    name: 'Phone',
    regex: /\b(\+\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}\b/g,
    replacement: '[REDACTED_PHONE]',
    severity: 'high'
  },

  // PHI Patterns (HIPAA)
  {
    type: 'PHI',
    name: 'MRN (Medical Record Number)',
    regex: /\bMRN[:\s]?\d{6,10}\b/gi,
    replacement: '[REDACTED_MRN]',
    severity: 'critical'
  },
  {
    type: 'PHI',
    name: 'Date of Birth',
    regex: /\b(0?[1-9]|1[0-2])[\/\-](0?[1-9]|[12]\d|3[01])[\/\-](\d{4}|\d{2})\b/g,
    replacement: '[REDACTED_DOB]',
    severity: 'critical'
  }
]

interface RedactionResult {
  redactedText: string
  detectedPII: Array<{
    type: string
    name: string
    severity: string
    count: number
  }>
  latency: number
}

function redactPIIRegex(text: string): RedactionResult {
  const startTime = Date.now()
  let redactedText = text
  const detected: Map<string, { type: string; name: string; severity: string; count: number }> = new Map()

  for (const pattern of REDACTION_PATTERNS) {
    const matches = text.match(pattern.regex)
    if (matches) {
      const count = matches.length
      detected.set(pattern.name, {
        type: pattern.type,
        name: pattern.name,
        severity: pattern.severity,
        count
      })

      redactedText = redactedText.replace(pattern.regex, pattern.replacement)
    }
  }

  return {
    redactedText,
    detectedPII: Array.from(detected.values()),
    latency: Date.now() - startTime
  }
}

/* Example:
Input: "Patient John Doe, SSN 123-45-6789, MRN: 1234567, DOB 01/15/1980"
Output: {
  redactedText: "Patient John Doe, [REDACTED_SSN], [REDACTED_MRN], [REDACTED_DOB]",
  detectedPII: [
    { type: "PII", name: "SSN", severity: "critical", count: 1 },
    { type: "PHI", name: "MRN", severity: "critical", count: 1 },
    { type: "PHI", name: "Date of Birth", severity: "critical", count: 1 }
  ],
  latency: 0.8  // <1ms
}
*/
```

### Phase 2: NLP-Based Names & Addresses (<5ms)

```typescript
import { pipeline } from '@xenova/transformers'  // Local NER model

// Load NER model once at startup (not per request)
const nerPipeline = await pipeline('ner', 'Xenova/bert-base-NER')

interface NERRedactionResult extends RedactionResult {
  entities: Array<{
    entity: string
    type: 'PERSON' | 'ORG' | 'LOC' | 'DATE'
    text: string
    start: number
    end: number
  }>
}

async function redactPIINER(text: string): Promise<NERRedactionResult> {
  const startTime = Date.now()

  // Step 1: Run NER model (local, no API call)
  const entities = await nerPipeline(text)

  // Step 2: Redact person names and locations
  let redactedText = text
  const detected: NERRedactionResult['entities'] = []

  for (const entity of entities) {
    if (entity.entity === 'B-PER' || entity.entity === 'I-PER') {
      // Person name ‚Üí PII
      detected.push({
        entity: entity.entity,
        type: 'PERSON',
        text: entity.word,
        start: entity.start,
        end: entity.end
      })

      redactedText = redactedText.replace(entity.word, '[REDACTED_NAME]')
    }

    if (entity.entity === 'B-LOC' || entity.entity === 'I-LOC') {
      // Location ‚Üí potential PHI (address)
      detected.push({
        entity: entity.entity,
        type: 'LOC',
        text: entity.word,
        start: entity.start,
        end: entity.end
      })

      redactedText = redactedText.replace(entity.word, '[REDACTED_LOC]')
    }
  }

  return {
    redactedText,
    detectedPII: [],  // Populated by regex phase
    entities: detected,
    latency: Date.now() - startTime
  }
}

/* Example:
Input: "Patient John Doe lives in San Francisco and works at Acme Corp"
Output: {
  redactedText: "Patient [REDACTED_NAME] [REDACTED_NAME] lives in [REDACTED_LOC] and works at Acme Corp",
  entities: [
    { entity: "B-PER", type: "PERSON", text: "John", start: 8, end: 12 },
    { entity: "I-PER", type: "PERSON", text: "Doe", start: 13, end: 16 },
    { entity: "B-LOC", type: "LOC", text: "San Francisco", start: 26, end: 39 }
  ],
  latency: 4.2  // <5ms
}
*/
```

### Production Redaction Pipeline

```typescript
async function redactionPipeline(text: string): Promise<{
  redactedText: string
  piiDetected: boolean
  phiDetected: boolean
  totalLatency: number
}> {
  const startTime = Date.now()

  // Phase 1: Regex (fast path for structured PII/PHI)
  const regexResult = redactPIIRegex(text)

  // Phase 2: NER (for names and locations)
  const nerResult = await redactPIINER(regexResult.redactedText)

  // Combine results
  const piiDetected = regexResult.detectedPII.some(d => d.type === 'PII') ||
                      nerResult.entities.some(e => e.type === 'PERSON')
  const phiDetected = regexResult.detectedPII.some(d => d.type === 'PHI')

  return {
    redactedText: nerResult.redactedText,
    piiDetected,
    phiDetected,
    totalLatency: Date.now() - startTime
  }
}

/* Performance:
- Regex phase: <1ms
- NER phase: <5ms
- Total: <6ms latency overhead
- Throughput: ~166 requests/second on single core
- Cost: $0 (local NER model, no API calls)
*/
```

## Data Residency: Local-First Inference Pattern

**The Problem**: Third-party LLM APIs route data through US servers, violating GDPR/HIPAA data residency requirements.

**Example Violation**:
```typescript
// ‚ùå GDPR Violation - EU user data sent to US servers
const europeanUserData = "User in Germany requested account deletion"
await anthropic.messages.create({  // Routes through US servers
  messages: [{ role: 'user', content: europeanUserData }]
})
// Violation: GDPR requires EU data stays in EU ‚Üí ‚Ç¨20M or 4% revenue fine
```

### Local-First Architecture: Keep PII in Your VPC

**Pattern**: Run smaller open-source models **locally** for PII-intensive tasks, only send redacted data to external APIs.

```typescript
interface LocalFirstConfig {
  piiThreshold: 'any' | 'critical' | 'none'
  localModel: {
    name: string
    size: string
    latency: number
    quality: number
  }
  externalModel: {
    name: string
    costPerMTok: number
    quality: number
  }
}

const LOCAL_FIRST_CONFIG: LocalFirstConfig = {
  piiThreshold: 'any',  // Route to local if ANY PII detected
  localModel: {
    name: 'mistral-7b-instruct',
    size: '7B parameters',
    latency: 500,   // ms p95
    quality: 0.85   // vs. Claude Sonnet = 1.0
  },
  externalModel: {
    name: 'claude-sonnet-4.5',
    costPerMTok: 3.0,
    quality: 1.0
  }
}

async function routeWithLocalFirst(
  userQuery: string
): Promise<{ response: string; routed: 'local' | 'external'; reason: string }> {
  // Step 1: Check for PII
  const redactionResult = await redactionPipeline(userQuery)

  // Step 2: Route decision
  if (redactionResult.piiDetected || redactionResult.phiDetected) {
    // PII detected ‚Üí MUST use local model (data residency requirement)
    const localResponse = await callLocalModel(userQuery)

    return {
      response: localResponse,
      routed: 'local',
      reason: 'PII/PHI detected - data residency requirement'
    }
  }

  // Step 3: No PII ‚Üí safe to use external API with redacted text
  const externalResponse = await anthropic.messages.create({
    model: 'claude-sonnet-4.5',
    max_tokens: 1024,
    messages: [{ role: 'user', content: redactionResult.redactedText }]
  })

  return {
    response: externalResponse.content[0].text,
    routed: 'external',
    reason: 'No PII detected - external API for quality'
  }
}

async function callLocalModel(query: string): Promise<string> {
  // Option 1: Ollama (local inference server)
  const response = await fetch('http://localhost:11434/api/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model: 'mistral',
      prompt: query,
      stream: false
    })
  })

  const result = await response.json()
  return result.response

  // Option 2: vLLM (production-grade local inference)
  // const response = await fetch('http://localhost:8000/v1/completions', {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify({
  //     model: 'mistralai/Mistral-7B-Instruct-v0.2',
  //     prompt: query,
  //     max_tokens: 1024
  //   })
  // })
}

/* Cost Analysis:
Local Model (Mistral 7B):
- Infrastructure: $500/month (GPU instance: g4dn.xlarge)
- Inference cost: $0 per request
- Throughput: ~10 requests/second
- Quality: 85% of Claude Sonnet

External Model (Claude Sonnet):
- Infrastructure: $0
- Inference cost: $0.006 per request (avg 2K tokens)
- Throughput: Unlimited
- Quality: 100% (baseline)

Break-even:
- Local model cost: $500/month fixed
- External model cost: $0.006 √ó requests
- Break-even: 500 / 0.006 = 83,333 requests/month
- If >83K requests/month with PII ‚Üí local is cheaper
- If <83K requests/month ‚Üí redaction + external is cheaper
*/
```

### HIPAA-Compliant Local-First Pattern

```typescript
interface HIPAAComplianceConfig {
  dataResidency: 'local' | 'us-only' | 'eu-only'
  encryptionAtRest: boolean
  encryptionInTransit: boolean
  auditLogging: boolean
  accessControls: 'strict' | 'standard'
}

const HIPAA_CONFIG: HIPAAComplianceConfig = {
  dataResidency: 'local',         // PHI never leaves VPC
  encryptionAtRest: true,         // AES-256 encryption
  encryptionInTransit: true,      // TLS 1.3
  auditLogging: true,             // Every access logged
  accessControls: 'strict'        // Role-based access
}

async function processHIPAAQuery(
  query: string,
  userId: string
): Promise<{ response: string; auditId: string }> {
  // Step 1: Detect PHI
  const redactionResult = await redactionPipeline(query)

  if (redactionResult.phiDetected) {
    // Step 2: PHI detected ‚Üí LOCAL ONLY (HIPAA requirement)
    const response = await callLocalModel(query)

    // Step 3: Audit log (HIPAA requirement)
    const auditId = await logHIPAAAccess({
      userId,
      accessType: 'llm_inference',
      phiDetected: true,
      dataResidency: 'local',
      timestamp: new Date()
    })

    return { response, auditId }
  }

  // Step 4: No PHI ‚Üí external API with redacted text
  const response = await anthropic.messages.create({
    model: 'claude-sonnet-4.5',
    max_tokens: 1024,
    messages: [{ role: 'user', content: redactionResult.redactedText }]
  })

  const auditId = await logHIPAAAccess({
    userId,
    accessType: 'llm_inference',
    phiDetected: false,
    dataResidency: 'external',
    timestamp: new Date()
  })

  return {
    response: response.content[0].text,
    auditId
  }
}

/* HIPAA Compliance Checklist:
‚úÖ PHI never sent to external APIs (local-first routing)
‚úÖ Encryption at rest (AES-256 for model weights and data)
‚úÖ Encryption in transit (TLS 1.3 for all connections)
‚úÖ Audit logging (every PHI access logged with timestamp, user, action)
‚úÖ Access controls (role-based access to local models)
‚úÖ Business Associate Agreement (BAA) with external API providers for non-PHI data
*/
```

## Key Takeaways

**High-Speed Redaction Pipeline**:
- **Phase 1**: Regex for structured PII/PHI (<1ms latency)
- **Phase 2**: Local NER for names/locations (<5ms latency)
- **Total overhead**: <6ms per request (transparent to users)
- **Cost**: $0 (no API calls, local NER model)

**Local-First Routing Decision**:
```typescript
// Decision tree:
if (PHI detected) {
  route ‚Üí local model (HIPAA requirement)
} else if (PII detected) {
  route ‚Üí local model if >83K req/month (cost-effective)
  route ‚Üí external with redaction if <83K req/month
} else {
  route ‚Üí external API (best quality)
}
```

**Data Residency Patterns**:
- **GDPR (EU)**: EU user data must stay in EU ‚Üí local model in EU region
- **HIPAA (Healthcare)**: PHI must stay in controlled environment ‚Üí local model in your VPC
- **CCPA (California)**: PII requires explicit consent for third-party processing ‚Üí redact or local

**Cost Analysis**:
```typescript
// Redaction Pipeline
- Regex phase: $0 (local)
- NER phase: $0 (local model)
- Total: $0 per request

// Local-First Infrastructure
- GPU instance (g4dn.xlarge): $500/month
- Break-even: 83,333 requests/month
- Quality trade-off: 85% of Claude Sonnet

// ROI: Prevents $1M+ HIPAA/GDPR fines ‚Üí 2,000:1 ROI minimum
```

**The Architect's Responsibility**:
You **own** data residency. If PHI reaches external APIs and you didn't implement Local-First, **you're responsible** for the HIPAA violation. If EU user data routes through US servers and you didn't check, **you're responsible** for the GDPR fine.

## Further Reading

- **HIPAA Technical Safeguards**: 45 CFR ¬ß 164.312
- **GDPR Article 44**: Transfers of personal data to third countries
- **Ollama**: Local LLM inference (https://ollama.ai)
- **vLLM**: Production-grade local inference (https://vllm.ai)
- **Presidio**: Microsoft's PII detection library (https://microsoft.github.io/presidio/)

## Next Concept

- **[AI Testing & NFRs](./ai-testing-nfrs.mdx)**: Production telemetry and SLA circuit breakers

## Compliance Patterns (Legacy Content)

### Equal Credit Opportunity Act (ECOA)

**Requirements**:
- Cannot discriminate based on race, color, religion, national origin, sex, marital status, age
- Must provide **adverse action notices** (reasons for denial)
- Must retain records for 25 months

### Adverse Action Notice

```typescript
interface AdverseActionNotice {
  applicantName: string
  date: Date
  decision: 'denied' | 'approved_with_conditions'
  principalReasons: string[]  // Must provide top reasons
  contactInfo: {
    name: string
    address: string
    phone: string
  }
  appealRights: string
}

async function generateAdverseActionNotice(
  application: LoanApplication,
  modelDecision: AIDecision
): Promise<AdverseActionNotice> {
  // ECOA requires top 4 reasons for denial
  const reasons = modelDecision.topFactors
    .filter(f => f.contribution < 0)  // Negative factors
    .slice(0, 4)
    .map(f => formatReasonForConsumer(f))

  return {
    applicantName: application.name,
    date: new Date(),
    decision: 'denied',
    principalReasons: reasons,
    contactInfo: {
      name: 'Credit Decision Team',
      address: '123 Finance St, New York, NY 10001',
      phone: '1-800-555-0100'
    },
    appealRights: 'You have the right to request a manual review within 30 days by contacting us at the number above.'
  }
}

function formatReasonForConsumer(factor: { feature: string; contribution: number }): string {
  const reasons = {
    credit_score: 'Credit score below minimum threshold',
    debt_to_income: 'Debt-to-income ratio too high',
    income: 'Insufficient income for requested loan amount',
    employment_length: 'Length of employment less than required',
    recent_delinquencies: 'Recent late payments or delinquencies'
  }

  return reasons[factor.feature] || 'Other credit factors'
}
```

### Fair Credit Reporting Act (FCRA)

**Model risk factors** (features) must be **reasonable and material**:

```typescript
const FCRA_APPROVED_FACTORS = [
  'credit_score',
  'payment_history',
  'outstanding_debt',
  'credit_utilization',
  'length_of_credit_history',
  'recent_credit_inquiries',
  'income',
  'employment_status'
]

const FCRA_PROHIBITED_FACTORS = [
  'race',
  'color',
  'religion',
  'national_origin',
  'sex',
  'marital_status',
  'age',  // Exception: can verify applicant is 18+
  'zip_code'  // Proxy for race
]

function validateFeatures(features: string[]): { valid: boolean; violations: string[] } {
  const prohibited = features.filter(f => FCRA_PROHIBITED_FACTORS.includes(f))

  return {
    valid: prohibited.length === 0,
    violations: prohibited
  }
}
```

### Dodd-Frank Stress Testing

```typescript
// Test model under adverse economic scenarios
async function stressTestCreditModel(
  model: MLModel,
  applications: LoanApplication[]
) {
  const scenarios = [
    { name: 'Recession', unemploymentRate: 0.10, gdpGrowth: -0.03 },
    { name: 'Market Crash', unemploymentRate: 0.08, gdpGrowth: -0.02 },
    { name: 'Baseline', unemploymentRate: 0.04, gdpGrowth: 0.02 }
  ]

  const results = await Promise.all(
    scenarios.map(async scenario => {
      // Adjust applicant data based on scenario
      const adjustedApps = applications.map(app => ({
        ...app,
        income: app.income * (1 + scenario.gdpGrowth),
        employmentRisk: scenario.unemploymentRate
      }))

      const predictions = await model.predictBatch(adjustedApps)
      const approvalRate = predictions.filter(p => p > 0.5).length / predictions.length

      return {
        scenario: scenario.name,
        approvalRate,
        expectedLosses: calculateExpectedLosses(predictions, adjustedApps)
      }
    })
  )

  return results
}
```

---

## Healthcare: HIPAA & Medical AI

### Protected Health Information (PHI)

**18 identifiers** that must be removed/encrypted:

```typescript
const PHI_IDENTIFIERS = [
  'names',
  'geographic_subdivisions_smaller_than_state',
  'dates',  // Except year for age > 89
  'telephone_numbers',
  'fax_numbers',
  'email_addresses',
  'social_security_numbers',
  'medical_record_numbers',
  'health_plan_beneficiary_numbers',
  'account_numbers',
  'certificate_license_numbers',
  'vehicle_identifiers',
  'device_identifiers',
  'urls',
  'ip_addresses',
  'biometric_identifiers',
  'full_face_photos',
  'any_unique_identifying_number'
]

async function deidentifyPHI(medicalText: string): Promise<string> {
  // Use NER model to detect PHI
  const entities = await detectEntities(medicalText)

  let deidentified = medicalText

  // Replace PHI with placeholders
  entities
    .filter(e => PHI_IDENTIFIERS.includes(e.type))
    .sort((a, b) => b.start - a.start)  // Replace from end to start
    .forEach(entity => {
      const placeholder = `[${entity.type.toUpperCase()}]`
      deidentified =
        deidentified.slice(0, entity.start) +
        placeholder +
        deidentified.slice(entity.end)
    })

  return deidentified
}

// Example:
// Input:  "Patient John Doe (SSN: 123-45-6789) visited on 2024-01-15"
// Output: "Patient [NAME] (SSN: [SSN]) visited on [DATE]"
```

### HIPAA Audit Trails

**Required logs** for AI systems processing PHI:

```typescript
interface HIPAAAuditLog {
  timestamp: Date
  userId: string
  action: 'access' | 'create' | 'update' | 'delete' | 'export'
  resourceType: 'patient_record' | 'diagnosis' | 'prescription' | 'image'
  resourceId: string
  ipAddress: string
  outcome: 'success' | 'failure'
  reason?: string
}

async function logHIPAAEvent(event: HIPAAAuditLog) {
  // Store in immutable append-only log
  await prisma.hipaaAuditLog.create({
    data: {
      ...event,
      hash: await hashEvent(event),  // Tamper detection
      previousHash: await getLastEventHash()
    }
  })

  // Alert on suspicious activity
  if (await detectSuspiciousPattern(event)) {
    await alertSecurityTeam(event)
  }
}
```

### Medical AI Decision Support

**FDA requirements** for AI as a medical device:

```typescript
interface MedicalAIMetadata {
  // Device identification
  deviceName: string
  intendedUse: string
  indications: string[]
  contraindications: string[]

  // Performance
  clinicalValidation: {
    studyName: string
    population: string
    sensitivity: number
    specificity: number
    auc: number
  }

  // Safety
  adverseEvents: string[]
  limitations: string[]
  warnings: string[]

  // Quality management
  version: string
  fda510kNumber?: string
  isoCompliance: string[]  // ISO 13485, ISO 14971
}

// Example: Diabetic retinopathy screening
const drScreeningAI: MedicalAIMetadata = {
  deviceName: 'RetinaAI Screening System',
  intendedUse: 'Detection of diabetic retinopathy in fundus images',
  indications: [
    'Adults with diabetes',
    'No history of diabetic retinopathy'
  ],
  contraindications: [
    'Patients with known retinopathy',
    'Poor quality images (< 80% gradable)'
  ],
  clinicalValidation: {
    studyName: 'EyePACS-1',
    population: '10,000 diabetic patients',
    sensitivity: 0.87,
    specificity: 0.90,
    auc: 0.94
  },
  adverseEvents: ['False negative: delayed treatment (0.13%)'],
  limitations: [
    'Does not detect other eye diseases',
    'Requires high-quality fundus images'
  ],
  warnings: [
    'Not a substitute for comprehensive eye exam',
    'Physician must review all flagged cases'
  ],
  version: '2.1.0',
  fda510kNumber: 'K203456',
  isoCompliance: ['ISO 13485:2016', 'ISO 14971:2019']
}
```

---

## Insurance: Risk Assessment Compliance

### NAIC Model Regulation

**National Association of Insurance Commissioners** requirements:

```typescript
interface InsuranceAIGovernance {
  // Model Inventory
  modelId: string
  modelName: string
  businessPurpose: string
  riskTier: 'high' | 'medium' | 'low'

  // Third-party models
  vendor?: string
  vendorValidation: boolean

  // Testing
  validationResults: {
    backtesting: BacktestResults
    sensitivityAnalysis: SensitivityResults
    outcomeAnalysis: OutcomeResults
  }

  // Ongoing monitoring
  performanceMetrics: {
    metric: string
    threshold: number
    current: number
    status: 'green' | 'yellow' | 'red'
  }[]

  // Documentation
  modelDocumentation: string  // Link to model card
  governanceCommitteeApproval: boolean
  boardReportingFrequency: 'monthly' | 'quarterly'
}

// Example: Auto insurance pricing model
async function validateInsuranceModel(
  model: MLModel,
  testData: PolicyApplication[]
) {
  // 1. Backtesting: Compare predictions to actual claims
  const backtest = await backtestModel(model, testData)

  // 2. Sensitivity: Ensure stable predictions
  const sensitivity = await testSensitivity(model, testData)

  // 3. Outcome analysis: Check for discriminatory patterns
  const outcomes = await analyzeOutcomes(model, testData)

  return {
    backtesting: backtest,
    sensitivityAnalysis: sensitivity,
    outcomeAnalysis: outcomes,
    passed: backtest.mae < 0.10 && !outcomes.hasDisparateTreatment
  }
}

async function analyzeOutcomes(
  model: MLModel,
  data: PolicyApplication[]
): Promise<OutcomeResults> {
  // Group by protected class
  const groups = groupBy(data, 'demographics')

  // Check for disparate treatment
  const premiumsByGroup = Object.keys(groups).map(group => ({
    group,
    avgPremium: average(groups[group].map(d => model.predict(d)))
  }))

  const maxDiff = Math.max(...premiumsByGroup.map(g => g.avgPremium)) -
                  Math.min(...premiumsByGroup.map(g => g.avgPremium))

  return {
    premiumsByGroup,
    maxDifference: maxDiff,
    hasDisparateTreatment: maxDiff > 0.20  // 20% threshold
  }
}
```

### Rate Filing Requirements

```typescript
// Must file rate changes with state insurance commissioner
async function generateRateFiling(
  model: MLModel,
  stateCode: string
) {
  return {
    state: stateCode,
    effectiveDate: addDays(new Date(), 60),  // 60-day notice

    // Actuarial memorandum
    actuarialSupport: {
      dataSource: 'Historical claims 2020-2024',
      methodology: 'Gradient Boosted Trees',
      lossRatio: 0.65,  // Target 65% loss ratio
      expenseRatio: 0.30,
      targetCombinedRatio: 0.95
    },

    // Rate factors
    rateFactors: await model.getFeatureImportances(),

    // Compliance attestation
    attestation: {
      notUnfairlyDiscriminatory: true,
      actuariallySupportedStatement: 'Rates are based on credible claims experience and statistical analysis',
      signedBy: 'Chief Actuary',
      date: new Date()
    }
  }
}
```

---

## HR/Hiring: Equal Employment Opportunity

### EEOC 80% Rule (Adverse Impact)

```typescript
async function checkAdverseImpact(
  applications: JobApplication[],
  protectedClass: 'gender' | 'race'
) {
  // Selection rate by group
  const groups = groupBy(applications, protectedClass)

  const selectionRates = Object.keys(groups).map(group => ({
    group,
    selected: groups[group].filter(a => a.hired).length,
    total: groups[group].length,
    rate: groups[group].filter(a => a.hired).length / groups[group].length
  }))

  // 80% rule: selection rate for protected group must be >= 80% of highest rate
  const highestRate = Math.max(...selectionRates.map(r => r.rate))

  const violations = selectionRates.filter(rate =>
    rate.rate < highestRate * 0.80
  )

  return {
    selectionRates,
    passed: violations.length === 0,
    violations,
    recommendation: violations.length > 0
      ? 'Manual review required: potential adverse impact detected'
      : 'No adverse impact detected'
  }
}

// Example:
// Men: 60/100 hired = 60% selection rate
// Women: 40/100 hired = 40% selection rate
// 40% < 60% * 0.80 (48%) ‚Üí VIOLATION
```

### Resume Screening Compliance

```typescript
const PROHIBITED_SCREENING_FACTORS = [
  'age',
  'gender',
  'race',
  'disability',
  'religion',
  'national_origin',
  'pregnancy',
  'genetic_information'
]

async function screenResume(resume: Resume): Promise<ScreeningResult> {
  // Remove prohibited information before AI analysis
  const sanitized = await removeProtectedInfo(resume)

  // Score based on job-related factors only
  const score = await model.predict({
    education: sanitized.education,
    experience: sanitized.experience,
    skills: sanitized.skills,
    // No: age, gender, photo, name (can indicate ethnicity)
  })

  return {
    score,
    recommendation: score > 0.7 ? 'interview' : 'reject',
    explanation: await generateExplanation(score),
    complianceChecked: true
  }
}
```

---

## Audit Trails for Compliance

### Immutable Audit Logs

```typescript
class ComplianceAuditLog {
  async logDecision(decision: AIDecision) {
    const previousHash = await this.getLastHash()

    const record = {
      timestamp: new Date(),
      decisionId: decision.id,
      userId: decision.userId,
      model: decision.modelVersion,
      input: decision.input,  // May need to redact PHI
      output: decision.output,
      explanation: decision.explanation,
      previousHash
    }

    const hash = await this.hash(record)

    await prisma.auditLog.create({
      data: { ...record, hash }
    })

    return hash
  }

  async verifyIntegrity() {
    const logs = await prisma.auditLog.findMany({
      orderBy: { timestamp: 'asc' }
    })

    for (let i = 1; i < logs.length; i++) {
      const currentHash = await this.hash(logs[i])
      const previousHash = logs[i - 1].hash

      if (logs[i].previousHash !== previousHash) {
        throw new Error(`Audit log tampered at record ${i}`)
      }

      if (logs[i].hash !== currentHash) {
        throw new Error(`Audit log corrupted at record ${i}`)
      }
    }

    return { verified: true, recordCount: logs.length }
  }

  private async hash(record: any): Promise<string> {
    const crypto = await import('crypto')
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(record))
      .digest('hex')
  }
}
```

### Retention Policies

```typescript
const RETENTION_POLICIES = {
  finance_ecoa: { years: 2.08 },  // 25 months
  finance_fcra: { years: 5 },
  healthcare_hipaa: { years: 6 },
  insurance_naic: { years: 5 },
  employment_eeoc: { years: 1 }
}

async function enforceRetentionPolicy(
  industry: keyof typeof RETENTION_POLICIES
) {
  const policy = RETENTION_POLICIES[industry]
  const cutoffDate = new Date()
  cutoffDate.setFullYear(cutoffDate.getFullYear() - policy.years)

  // Archive old records (don't delete - may need for litigation)
  await prisma.auditLog.updateMany({
    where: {
      timestamp: { lt: cutoffDate },
      archived: false
    },
    data: { archived: true }
  })
}
```

---

## Key Takeaways

1. **Know your regulations**: Finance (ECOA/FCRA), Healthcare (HIPAA), Insurance (NAIC), HR (EEOC)
2. **Document decisions**: Adverse action notices, explanations required
3. **Audit everything**: Immutable logs, tamper detection
4. **Test for bias**: 80% rule for hiring, disparate impact for lending
5. **Protect sensitive data**: Deidentify PHI, encrypt PII
6. **Retain records**: 25 months (ECOA), 5 years (FCRA/NAIC), 6 years (HIPAA)

## Further Reading

- **Finance**: [CFPB - Using AI in Credit Underwriting](https://www.consumerfinance.gov/)
- **Healthcare**: [HHS - HIPAA for Developers](https://www.hhs.gov/hipaa/for-professionals/security/guidance/index.html)
- **Insurance**: [NAIC - AI Model Governance](https://content.naic.org/sites/default/files/inline-files/AI%20Model%20Bulletin%202023.pdf)
- **Employment**: [EEOC - AI and Title VII](https://www.eeoc.gov/ai)

> **Important**: Consult legal counsel for specific compliance requirements. This guide provides technical implementation patterns but is not legal advice.
