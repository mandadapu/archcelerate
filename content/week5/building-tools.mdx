# Building Tools for AI Agents

Learn how to create robust, reliable tools that AI agents can use effectively to interact with the world.

## What Are Tools?

In the context of AI agents, **tools** are functions that extend the agent's capabilities beyond text generation. They allow agents to:

- Fetch real-time data (weather, stock prices, news)
- Interact with APIs (search, databases, external services)
- Perform computations (calculations, data processing)
- Take actions (send emails, create files, make purchases)

### Anatomy of a Tool

Every tool has four essential components:

```typescript
interface Tool {
  // 1. Unique identifier
  name: string

  // 2. Description for the agent (critical for tool selection)
  description: string

  // 3. Input schema (JSON Schema for validation)
  input_schema: {
    type: 'object'
    properties: Record<string, any>
    required?: string[]
  }

  // 4. Execution function (your implementation)
  execute: (input: any) => Promise<any>
}
```

## Tool Definition Structure

### 1. Name

Choose clear, action-oriented names:

```typescript
// Good: Verb + noun, clear purpose
'get_weather'
'search_database'
'send_email'
'calculate_distance'

// Bad: Vague or unclear
'weather'
'search'
'email_thing'
'calc'
```

### 2. Description

The description is how the agent decides when to use your tool. Make it:
- **Specific**: What exactly does it do?
- **Contextual**: When should it be used?
- **Informative**: What does it return?

```typescript
// Good: Complete, specific description
{
  name: 'get_weather',
  description: 'Get current weather conditions for any city worldwide. Returns temperature in Fahrenheit, conditions (sunny/cloudy/rainy), humidity percentage, and wind speed in mph. Use this when users ask about current weather, temperature, or weather conditions.'
}

// Bad: Too vague
{
  name: 'get_weather',
  description: 'Gets weather'
}

// Bad: Too verbose (wastes tokens)
{
  name: 'get_weather',
  description: 'This is a comprehensive weather tool that can be used to retrieve meteorological data including but not limited to temperature readings, atmospheric pressure, humidity levels, precipitation forecasts, wind speeds and directions, cloud coverage percentages, UV index ratings...' // 200 more words
}
```

### 3. Input Schema

Use JSON Schema to define parameters:

```typescript
const weatherTool: Tool = {
  name: 'get_weather',
  description: 'Get current weather for a location',
  input_schema: {
    type: 'object',
    properties: {
      location: {
        type: 'string',
        description: 'City name or coordinates (e.g., "Paris" or "48.8566,2.3522")'
      },
      units: {
        type: 'string',
        enum: ['celsius', 'fahrenheit'],
        description: 'Temperature units (default: fahrenheit)'
      }
    },
    required: ['location']
  },
  execute: async (input) => {
    // Implementation
  }
}
```

### JSON Schema Types

```typescript
// String parameter
{
  type: 'string',
  description: 'User email address',
  pattern: '^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$' // Optional regex validation
}

// Number parameter
{
  type: 'number',
  description: 'Product price in USD',
  minimum: 0,
  maximum: 10000
}

// Boolean parameter
{
  type: 'boolean',
  description: 'Whether to send confirmation email'
}

// Enum (limited choices)
{
  type: 'string',
  enum: ['low', 'medium', 'high'],
  description: 'Priority level'
}

// Array parameter
{
  type: 'array',
  items: { type: 'string' },
  description: 'List of email recipients',
  minItems: 1,
  maxItems: 10
}

// Object parameter (nested)
{
  type: 'object',
  properties: {
    name: { type: 'string' },
    age: { type: 'number' }
  },
  required: ['name']
}
```

## Tool Execution and Error Handling

### Basic Execution Pattern

```typescript
export const searchTool: Tool = {
  name: 'search_web',
  description: 'Search the internet for current information on any topic',
  input_schema: {
    type: 'object',
    properties: {
      query: {
        type: 'string',
        description: 'Search query'
      }
    },
    required: ['query']
  },
  execute: async (input: { query: string }) => {
    try {
      // 1. Validate input (optional - schema handles most cases)
      if (!input.query || input.query.trim().length === 0) {
        return 'Error: Search query cannot be empty'
      }

      // 2. Call external API
      const response = await fetch(
        `https://api.search.com/search?q=${encodeURIComponent(input.query)}`
      )

      if (!response.ok) {
        return `Error: Search API returned status ${response.status}`
      }

      // 3. Process response
      const data = await response.json()

      // 4. Return structured result
      return JSON.stringify({
        results: data.results.slice(0, 5).map((r: any) => ({
          title: r.title,
          snippet: r.snippet,
          url: r.url
        })),
        total: data.total_results
      })
    } catch (error) {
      // 5. Handle errors gracefully
      return `Error searching web: ${error instanceof Error ? error.message : 'Unknown error'}`
    }
  }
}
```

### Error Handling Best Practices

```typescript
async execute(input: any) {
  try {
    // Your tool logic
    return result
  } catch (error) {
    // Return error as string (don't throw)
    // This allows the agent to adapt
    if (error instanceof NetworkError) {
      return 'Error: Network connection failed. Please try again.'
    }

    if (error instanceof RateLimitError) {
      return 'Error: Rate limit exceeded. Please wait a moment and try again.'
    }

    if (error instanceof ValidationError) {
      return `Error: Invalid input - ${error.message}`
    }

    // Generic fallback
    return `Error: ${error instanceof Error ? error.message : 'Unknown error occurred'}`
  }
}
```

### Why Return Errors Instead of Throwing?

```typescript
// Bad: Throwing errors crashes the agent
execute: async (input) => {
  throw new Error('API failed') // Agent stops completely
}

// Good: Returning errors lets the agent adapt
execute: async (input) => {
  return 'Error: API failed. Try using the backup_search tool instead.'
  // Agent can see the error and try something else
}
```

## Real-World Tool Examples

### Example 1: Weather Tool

```typescript
export const weatherTool: Tool = {
  name: 'get_weather',
  description: 'Get current weather for a location. Returns temperature, conditions, humidity, and wind speed.',
  input_schema: {
    type: 'object',
    properties: {
      location: {
        type: 'string',
        description: 'City name or coordinates'
      },
      units: {
        type: 'string',
        enum: ['celsius', 'fahrenheit'],
        description: 'Temperature units (default: fahrenheit)'
      }
    },
    required: ['location']
  },
  execute: async (input: { location: string; units?: string }) => {
    try {
      const units = input.units || 'fahrenheit'

      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(input.location)}&appid=${process.env.WEATHER_API_KEY}&units=${units === 'celsius' ? 'metric' : 'imperial'}`
      )

      if (!response.ok) {
        if (response.status === 404) {
          return `Error: Location "${input.location}" not found. Please check spelling or try a different location.`
        }
        return `Error: Weather service unavailable (status ${response.status})`
      }

      const data = await response.json()

      const weatherReport = {
        location: data.name,
        temperature: `${Math.round(data.main.temp)}째${units === 'celsius' ? 'C' : 'F'}`,
        conditions: data.weather[0].description,
        humidity: `${data.main.humidity}%`,
        wind_speed: `${data.wind.speed} ${units === 'celsius' ? 'm/s' : 'mph'}`
      }

      return `Weather in ${weatherReport.location}:
Temperature: ${weatherReport.temperature}
Conditions: ${weatherReport.conditions}
Humidity: ${weatherReport.humidity}
Wind: ${weatherReport.wind_speed}`
    } catch (error) {
      return `Error fetching weather: ${error instanceof Error ? error.message : 'Unknown error'}`
    }
  }
}
```

### Example 2: File Read Tool

```typescript
import { readFile } from 'fs/promises'
import { join } from 'path'

export const fileReadTool: Tool = {
  name: 'read_file',
  description: 'Read contents of a text file. Only works with .txt, .md, .json, .js, .ts files. Returns file contents as string.',
  input_schema: {
    type: 'object',
    properties: {
      file_path: {
        type: 'string',
        description: 'Path to the file to read (relative to project root)'
      }
    },
    required: ['file_path']
  },
  execute: async (input: { file_path: string }) => {
    try {
      // Security: Prevent path traversal attacks
      const safePath = join(process.cwd(), input.file_path).replace(/\.\./g, '')

      // Security: Only allow certain file types
      const allowedExtensions = ['.txt', '.md', '.json', '.js', '.ts']
      const hasAllowedExt = allowedExtensions.some(ext => safePath.endsWith(ext))

      if (!hasAllowedExt) {
        return `Error: File type not allowed. Supported types: ${allowedExtensions.join(', ')}`
      }

      const content = await readFile(safePath, 'utf-8')

      // Limit output size to prevent overwhelming the agent
      const MAX_SIZE = 10000
      if (content.length > MAX_SIZE) {
        return `File content (first ${MAX_SIZE} characters):\n${content.substring(0, MAX_SIZE)}\n\n[File truncated - total size: ${content.length} characters]`
      }

      return `File content of ${input.file_path}:\n${content}`
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        return `Error: File "${input.file_path}" not found`
      }
      if ((error as NodeJS.ErrnoException).code === 'EACCES') {
        return `Error: Permission denied reading "${input.file_path}"`
      }
      return `Error reading file: ${error instanceof Error ? error.message : 'Unknown error'}`
    }
  }
}
```

### Example 3: Calculator Tool

```typescript
import { evaluate } from 'mathjs'

export const calculatorTool: Tool = {
  name: 'calculator',
  description: 'Evaluate mathematical expressions. Supports basic arithmetic (+, -, *, /), exponents (^), and common functions (sqrt, sin, cos, log). Example: "2 + 2" or "sqrt(16) * 3"',
  input_schema: {
    type: 'object',
    properties: {
      expression: {
        type: 'string',
        description: 'Mathematical expression to evaluate'
      }
    },
    required: ['expression']
  },
  execute: async (input: { expression: string }) => {
    try {
      // Security: Sanitize input to prevent code injection
      const sanitized = input.expression.replace(/[^0-9+\-*/().^a-z\s]/gi, '')

      if (sanitized !== input.expression) {
        return `Error: Expression contains invalid characters. Use only numbers, operators (+, -, *, /, ^), and functions (sqrt, sin, cos, etc.)`
      }

      const result = evaluate(sanitized)

      // Format result
      if (typeof result === 'number') {
        // Round to reasonable precision
        const rounded = Math.round(result * 1000000) / 1000000
        return `${input.expression} = ${rounded}`
      }

      return `${input.expression} = ${result}`
    } catch (error) {
      return `Error evaluating expression: ${error instanceof Error ? error.message : 'Invalid mathematical expression'}`
    }
  }
}
```

### Example 4: Database Search Tool

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export const searchProductsTool: Tool = {
  name: 'search_products',
  description: 'Search the product database by name, category, or description. Returns up to 10 matching products with their prices and availability.',
  input_schema: {
    type: 'object',
    properties: {
      query: {
        type: 'string',
        description: 'Search query (product name, category, or keyword)'
      },
      max_results: {
        type: 'number',
        description: 'Maximum number of results to return (default: 10)',
        minimum: 1,
        maximum: 50
      }
    },
    required: ['query']
  },
  execute: async (input: { query: string; max_results?: number }) => {
    try {
      const limit = input.max_results || 10

      const products = await prisma.product.findMany({
        where: {
          OR: [
            { name: { contains: input.query, mode: 'insensitive' } },
            { category: { contains: input.query, mode: 'insensitive' } },
            { description: { contains: input.query, mode: 'insensitive' } }
          ]
        },
        take: limit,
        select: {
          id: true,
          name: true,
          price: true,
          category: true,
          in_stock: true
        }
      })

      if (products.length === 0) {
        return `No products found matching "${input.query}"`
      }

      const results = products.map(p =>
        `${p.name} ($${p.price}) - ${p.category} - ${p.in_stock ? 'In Stock' : 'Out of Stock'}`
      ).join('\n')

      return `Found ${products.length} product(s):\n${results}`
    } catch (error) {
      return `Error searching database: ${error instanceof Error ? error.message : 'Unknown error'}`
    }
  }
}
```

## Tool Composition

Combine multiple tools to create more powerful agents:

```typescript
// Basic tools
const tools = [
  weatherTool,
  searchTool,
  calculatorTool,
  fileReadTool
]

// Agent can now:
// 1. Search for information
// 2. Read files to get context
// 3. Do calculations on data
// 4. Check weather for recommendations

// Example query: "Read sales_data.json, calculate total revenue,
// and recommend outdoor activities if weather is good"
```

### Tool Dependencies

Some tools work better together:

```typescript
// Travel planning agent
const travelTools = [
  searchFlightsTool,      // Find flights
  checkWeatherTool,       // Check destination weather
  findHotelsTool,         // Search hotels
  calculateBudgetTool,    // Calculate total cost
  createItineraryTool     // Compile final plan
]

// The agent can use these in sequence:
// 1. Search flights
// 2. Check weather at destination
// 3. Find hotels near attractions
// 4. Calculate total budget
// 5. Create final itinerary
```

## Best Practices

### 1. Make Tools Idempotent

Tools should produce the same result when called multiple times with the same input:

```typescript
// Good: Idempotent - always returns same weather for same location
async execute(input: { location: string }) {
  return await getWeather(input.location)
}

// Bad: Not idempotent - creates new record each time
async execute(input: { userId: string }) {
  return await createUser(input.userId) // Creates duplicate users!
}

// Better: Check before creating
async execute(input: { userId: string }) {
  const existing = await findUser(input.userId)
  if (existing) {
    return `User ${input.userId} already exists`
  }
  return await createUser(input.userId)
}
```

### 2. Return Structured, Parseable Results

```typescript
// Good: Structured, easy to parse
return JSON.stringify({
  status: 'success',
  temperature: 72,
  conditions: 'sunny',
  location: 'San Francisco'
})

// Okay: Formatted text, still informative
return `Weather in San Francisco: 72째F, Sunny`

// Bad: Ambiguous, hard to parse
return `72`
```

### 3. Include Error Context

```typescript
// Good: Specific, actionable error
return 'Error: API rate limit exceeded. Please wait 60 seconds and try again.'

// Bad: Generic, unhelpful
return 'Error: Failed'
```

### 4. Validate Before Expensive Operations

```typescript
execute: async (input: { email: string; message: string }) => {
  // Validate BEFORE sending email
  if (!input.email.includes('@')) {
    return 'Error: Invalid email address format'
  }

  if (input.message.length > 10000) {
    return 'Error: Message too long (max 10,000 characters)'
  }

  // Now send email
  return await sendEmail(input.email, input.message)
}
```

### 5. Limit Output Size

Agents have token limits - don't overwhelm them:

```typescript
execute: async (input: { query: string }) => {
  const results = await searchDatabase(input.query)

  // Limit number of results
  const limited = results.slice(0, 10)

  // Truncate long descriptions
  const formatted = limited.map(r => ({
    ...r,
    description: r.description.substring(0, 200)
  }))

  return JSON.stringify(formatted)
}
```

### 6. Use Clear Parameter Names

```typescript
// Good: Self-explanatory
{
  properties: {
    recipient_email: { type: 'string' },
    message_body: { type: 'string' },
    send_copy_to_sender: { type: 'boolean' }
  }
}

// Bad: Unclear abbreviations
{
  properties: {
    rcpt: { type: 'string' },
    msg: { type: 'string' },
    cc: { type: 'boolean' }
  }
}
```

### 7. Provide Usage Examples in Descriptions

```typescript
{
  name: 'convert_currency',
  description: 'Convert amount from one currency to another using current exchange rates. Example: convert_currency(100, "USD", "EUR") converts $100 to euros.',
  input_schema: {
    type: 'object',
    properties: {
      amount: { type: 'number', description: 'Amount to convert' },
      from_currency: { type: 'string', description: 'Source currency code (USD, EUR, GBP, etc.)' },
      to_currency: { type: 'string', description: 'Target currency code (USD, EUR, GBP, etc.)' }
    },
    required: ['amount', 'from_currency', 'to_currency']
  }
}
```

## Testing Tools

Always test your tools independently before giving them to an agent:

```typescript
// test/tools/weather.test.ts
import { describe, it, expect } from 'vitest'
import { weatherTool } from '../tools/weather'

describe('weatherTool', () => {
  it('should return weather for valid location', async () => {
    const result = await weatherTool.execute({ location: 'London' })
    expect(result).toContain('Weather in London')
    expect(result).toContain('Temperature:')
  })

  it('should handle invalid location gracefully', async () => {
    const result = await weatherTool.execute({ location: 'InvalidCity12345' })
    expect(result).toContain('Error')
    expect(result).toContain('not found')
  })

  it('should respect units parameter', async () => {
    const celsius = await weatherTool.execute({
      location: 'Paris',
      units: 'celsius'
    })
    expect(celsius).toContain('째C')

    const fahrenheit = await weatherTool.execute({
      location: 'Paris',
      units: 'fahrenheit'
    })
    expect(fahrenheit).toContain('째F')
  })

  it('should handle network errors gracefully', async () => {
    // Mock network failure
    const result = await weatherTool.execute({ location: 'London' })
    expect(result).not.toThrow()
  })
})
```

## Summary

In this lesson, you learned:

- The anatomy of a tool (name, description, schema, execute function)
- How to define parameter schemas with JSON Schema
- Error handling patterns for reliable tools
- Real-world tool examples (weather, file read, calculator, database)
- Best practices for tool design (idempotency, validation, error messages)
- How to test tools independently

Well-designed tools make the difference between an agent that works reliably and one that fails unpredictably. In the next lesson, you'll learn how to debug agents when things go wrong.

## Further Reading

- [Anthropic Tool Use Guide](https://docs.anthropic.com/claude/docs/tool-use)
- [JSON Schema Documentation](https://json-schema.org/understanding-json-schema/)
- [Tool Use Best Practices](https://docs.anthropic.com/claude/docs/tool-use-best-practices)
