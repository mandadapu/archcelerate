---
title: "Supervisor & Collaborative Patterns: Manager Agents and Swarms"
week: 5
concept: 2
description: "Engineering Manager agents that delegate to specialists and collaborative swarms that solve problems in parallel"
estimatedMinutes: 40
objectives:
  - Implement Supervisor pattern with Manager agent orchestration
  - Build specialist agents with validation and feedback loops
  - Design Collaborative Swarms using Blackboard architecture
---

# Supervisor & Collaborative Patterns

Defining the "Who" and "How" of agent teamwork in production systems.

## The Central Question

**When do you need multiple specialized agents?**

- ‚ùå **Don't use multiple agents** if: A single agent with tools can solve it
- ‚úÖ **Use Supervisor pattern** if: Task requires distinct specialized skills (frontend + backend + database)
- ‚úÖ **Use Collaborative Swarms** if: Task benefits from parallel exploration with multiple perspectives

---

## Pattern 1: The Supervisor (Manager + Specialists)

**Structure**: A Manager agent coordinates specialist agents, deciding who works on what and validating output before proceeding.

```
            Manager Agent
           (Task Router & Validator)
                  |
        +---------+---------+
        |         |         |
    Frontend   Backend   Database
    Specialist Specialist Specialist
        |         |         |
        +---------+---------+
                  |
              Manager
            (Integration)
```

### When to Use Supervisor Pattern

| Use Case | Why Supervisor? |
|----------|-----------------|
| Full-stack app development | Requires frontend, backend, and database expertise |
| Research report | Needs researcher, fact-checker, and writer roles |
| Code review | Requires coder, tester, and reviewer perspectives |

**Key Principle**: Manager validates specialist output and provides feedback if quality is insufficient.

### Supervisor Architecture

```typescript
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })

interface SpecialistTask {
  specialist: 'frontend' | 'backend' | 'database'
  description: string
  context: string  // What previous specialists produced
}

interface SpecialistResult {
  specialist: string
  output: string
  quality: 'approved' | 'needs_revision'
  feedback?: string
}

interface SupervisorState {
  userRequest: string
  tasks: SpecialistTask[]
  results: Record<string, SpecialistResult>
  integrationPlan: string
  finalOutput: string | null
}

// Manager Agent: Routes tasks and validates output
async function managerAgent(userRequest: string, previousResults: Record<string, SpecialistResult> = {}): Promise<{
  tasks: SpecialistTask[]
  integrationPlan: string
}> {
  const context = Object.keys(previousResults).length > 0
    ? `\nPrevious work completed:\n${Object.entries(previousResults)
        .map(([specialist, result]) =>
          `${specialist}: ${result.quality}\n${result.output.substring(0, 200)}...`
        ).join('\n\n')}`
    : ''

  const prompt = `You are a project manager coordinating specialist agents.

User Request: "${userRequest}"
${context}

Your job:
1. Break down the request into tasks for specialists
2. Provide clear, specific instructions for each specialist
3. Ensure specialists have context from previous work
4. Define how their outputs will integrate

Available specialists:
- frontend: React/TypeScript UI components
- backend: Node.js/Express API routes with Prisma
- database: PostgreSQL schema design and migrations

Output JSON:
{
  "tasks": [
    {
      "specialist": "database",
      "description": "Design user authentication schema with email, password hash, sessions table",
      "context": ""
    },
    {
      "specialist": "backend",
      "description": "Implement /api/auth/signup and /api/auth/login endpoints using Prisma",
      "context": "Use the database schema from the database specialist"
    },
    {
      "specialist": "frontend",
      "description": "Build LoginForm and SignupForm components that call backend APIs",
      "context": "Backend APIs: POST /api/auth/signup, POST /api/auth/login"
    }
  ],
  "integrationPlan": "Database migration runs first, then backend server starts with Prisma client, finally frontend calls authenticated endpoints"
}`

  const response = await anthropic.messages.create({
    model: 'claude-4.5-sonnet',
    max_tokens: 2048,
    messages: [{ role: 'user', content: prompt }]
  })

  const planText = response.content[0].text
  const jsonMatch = planText.match(/\{[\s\S]*\}/)
  if (!jsonMatch) throw new Error('Manager failed to generate valid plan')

  return JSON.parse(jsonMatch[0])
}

// Specialist Agents
async function frontendSpecialist(task: SpecialistTask): Promise<string> {
  const prompt = `You are a senior frontend developer specializing in React and TypeScript.

Task: ${task.description}

Context: ${task.context || 'No prior context'}

Generate production-ready code with:
- TypeScript interfaces for props and state
- Proper error handling
- Accessible HTML
- Comments explaining key decisions

Provide your implementation.`

  const response = await anthropic.messages.create({
    model: 'claude-4.5-sonnet',
    max_tokens: 3000,
    system: 'You are a senior frontend developer. Output clean, production-ready React code.',
    messages: [{ role: 'user', content: prompt }]
  })

  return response.content[0].text
}

async function backendSpecialist(task: SpecialistTask): Promise<string> {
  const prompt = `You are a senior backend developer specializing in Node.js and API design.

Task: ${task.description}

Context: ${task.context || 'No prior context'}

Generate production-ready code with:
- Input validation (Zod schemas)
- Error handling
- Security best practices (password hashing, SQL injection prevention)
- Comments explaining key decisions

Provide your implementation.`

  const response = await anthropic.messages.create({
    model: 'claude-4.5-sonnet',
    max_tokens: 3000,
    system: 'You are a senior backend developer. Output secure, production-ready API code.',
    messages: [{ role: 'user', content: prompt }]
  })

  return response.content[0].text
}

async function databaseSpecialist(task: SpecialistTask): Promise<string> {
  const prompt = `You are a database architect specializing in PostgreSQL and Prisma.

Task: ${task.description}

Context: ${task.context || 'No prior context'}

Generate:
- Prisma schema with proper relationships
- Indexes for performance
- Constraints for data integrity
- Migration-ready schema

Provide your schema design.`

  const response = await anthropic.messages.create({
    model: 'claude-4.5-sonnet',
    max_tokens: 2000,
    system: 'You are a database architect. Output production-ready Prisma schemas.',
    messages: [{ role: 'user', content: prompt }]
  })

  return response.content[0].text
}

// Manager Validator: Checks specialist output quality
async function validateSpecialistOutput(
  specialist: string,
  output: string,
  task: SpecialistTask
): Promise<SpecialistResult> {
  const prompt = `You are reviewing ${specialist} specialist's work.

Task assigned: ${task.description}
Output produced:
${output}

Evaluate:
1. Does it fully address the task?
2. Is the code production-ready (error handling, security, best practices)?
3. Are there any critical issues?

Output JSON:
{
  "quality": "approved" or "needs_revision",
  "feedback": "Specific issues to fix, or 'Good work' if approved"
}`

  const response = await anthropic.messages.create({
    model: 'claude-4.5-sonnet',
    max_tokens: 1024,
    messages: [{ role: 'user', content: prompt }]
  })

  const validationText = response.content[0].text
  const jsonMatch = validationText.match(/\{[\s\S]*\}/)
  if (!jsonMatch) throw new Error('Validation failed')

  const validation = JSON.parse(jsonMatch[0])

  return {
    specialist,
    output,
    quality: validation.quality,
    feedback: validation.feedback
  }
}

// Supervisor Workflow
async function supervisorWorkflow(userRequest: string): Promise<SupervisorState> {
  const state: SupervisorState = {
    userRequest,
    tasks: [],
    results: {},
    integrationPlan: '',
    finalOutput: null
  }

  // Step 1: Manager creates plan
  console.log('üß† Manager: Planning tasks...')
  const plan = await managerAgent(userRequest)
  state.tasks = plan.tasks
  state.integrationPlan = plan.integrationPlan
  console.log(`‚úÖ Plan: ${state.tasks.length} tasks\n`)

  // Step 2: Execute specialists sequentially (respecting dependencies)
  for (const task of state.tasks) {
    let attempts = 0
    let approved = false

    while (attempts < 3 && !approved) {
      attempts++
      console.log(`‚öôÔ∏è  ${task.specialist} specialist (attempt ${attempts})...`)

      // Call specialist
      let output: string
      if (task.specialist === 'frontend') output = await frontendSpecialist(task)
      else if (task.specialist === 'backend') output = await backendSpecialist(task)
      else if (task.specialist === 'database') output = await databaseSpecialist(task)
      else throw new Error(`Unknown specialist: ${task.specialist}`)

      // Manager validates
      console.log('üîç Manager: Validating output...')
      const validation = await validateSpecialistOutput(task.specialist, output, task)

      if (validation.quality === 'approved') {
        approved = true
        state.results[task.specialist] = validation
        console.log(`‚úÖ Approved: ${task.specialist}\n`)
      } else {
        console.log(`‚ùå Needs revision: ${validation.feedback}`)
        // Provide feedback to specialist on next attempt
        task.context += `\n\nManager Feedback: ${validation.feedback}`
      }
    }

    if (!approved) {
      throw new Error(`${task.specialist} failed after 3 attempts`)
    }
  }

  // Step 3: Manager integrates outputs
  console.log('üîó Manager: Integrating specialist outputs...')
  const integrationPrompt = `All specialists have completed their work. Integrate their outputs into a cohesive solution.

User Request: "${userRequest}"

Specialist Outputs:
${Object.entries(state.results)
  .map(([specialist, result]) => `**${specialist}**:\n${result.output}`)
  .join('\n\n---\n\n')}

Integration Plan: ${state.integrationPlan}

Provide:
1. Final integrated code
2. Instructions for running the system
3. Any remaining TODOs`

  const integrationResponse = await anthropic.messages.create({
    model: 'claude-4.5-sonnet',
    max_tokens: 4000,
    messages: [{ role: 'user', content: integrationPrompt }]
  })

  state.finalOutput = integrationResponse.content[0].text
  console.log('‚úÖ Integration complete\n')

  return state
}

// Usage
const result = await supervisorWorkflow(
  "Build a user authentication system with signup, login, and session management"
)

console.log('üì¶ Final Output:')
console.log(result.finalOutput)
```

### Supervisor Pattern: Key Benefits

| Benefit | Implementation |
|---------|----------------|
| **Specialist expertise** | Each agent has a focused system prompt |
| **Quality gates** | Manager validates before accepting output |
| **Feedback loops** | Specialists get up to 3 attempts with guidance |
| **Clear dependencies** | Database ‚Üí Backend ‚Üí Frontend ordering |
| **Audit trail** | Every task and validation is logged |

**Cost Analysis**:
```typescript
// Supervisor workflow (3 specialists, 1 validation each)
- Manager planning: 500 input + 800 output = $0.0135
- Database specialist: 1000 input + 1500 output = $0.0255
- Backend specialist: 1500 input + 2500 output = $0.042
- Frontend specialist: 1500 input + 2500 output = $0.042
- 3 validations: 3 √ó (1500 input + 300 output) = $0.027
- Integration: 3000 input + 3000 output = $0.054
- Total: $0.204 for complete full-stack feature

// Single monolithic prompt (no specialists)
- Cost: $0.05
- Quality: 60% (frontend calls wrong API, no validation, security holes)
- Real cost: $0.05 + $500 fixing bugs in production

// Verdict: Supervisor adds 4x cost but prevents production bugs
```

---

## Pattern 2: Collaborative Swarms (Blackboard Architecture)

**Structure**: Decentralized agents communicate through a shared "Blackboard" (message bus), solving problems in parallel without a central manager.

```
        Shared Blackboard
              (State)
          /    |    |    \
         /     |    |     \
    Agent1  Agent2 Agent3  Agent4
     (Read)  (Write) (Read) (Write)
```

### When to Use Collaborative Swarms

| Use Case | Why Swarms? |
|----------|-------------|
| Brainstorming sessions | Multiple perspectives improve creativity |
| Research tasks | Parallel exploration of different sources |
| Code review | Multiple reviewers catch different issues |

**Key Difference from Supervisor**: No single manager; agents self-coordinate by reading/writing to shared state.

### Blackboard Architecture

```typescript
import { StateGraph, Annotation } from '@langchain/langgraph'

// Shared Blackboard State
const BlackboardState = Annotation.Root({
  topic: Annotation<string>(),
  contributions: Annotation<Array<{
    agentId: string
    timestamp: Date
    content: string
    upvotes: number
  }>>(),
  finalSynthesis: Annotation<string | null>()
})

type BlackboardStateType = typeof BlackboardState.State

// Agent Base Class
class CollaborativeAgent {
  constructor(
    public id: string,
    public role: string,
    public systemPrompt: string
  ) {}

  async contribute(blackboard: BlackboardStateType): Promise<string> {
    // Read what other agents have written
    const context = blackboard.contributions.length > 0
      ? `\nPrevious contributions:\n${blackboard.contributions
          .map(c => `[${c.agentId}]: ${c.content}`)
          .join('\n\n')}`
      : ''

    const prompt = `${this.systemPrompt}

Topic: ${blackboard.topic}
${context}

Provide your unique perspective or build on others' ideas. Add something new, don't repeat.`

    const response = await anthropic.messages.create({
      model: 'claude-4.5-sonnet',
      max_tokens: 1500,
      messages: [{ role: 'user', content: prompt }]
    })

    return response.content[0].text
  }
}

// Specialized Agents
const agents = [
  new CollaborativeAgent(
    'optimist',
    'Optimistic Analyzer',
    'You focus on opportunities, strengths, and positive outcomes. You see the glass half-full.'
  ),
  new CollaborativeAgent(
    'pessimist',
    'Critical Analyzer',
    'You identify risks, weaknesses, and potential failures. You see the glass half-empty.'
  ),
  new CollaborativeAgent(
    'pragmatist',
    'Pragmatic Analyst',
    'You focus on practical execution, costs, and feasibility. You ask "how do we actually build this?"'
  ),
  new CollaborativeAgent(
    'innovator',
    'Creative Thinker',
    'You explore unconventional approaches and radical alternatives. You challenge assumptions.'
  )
]

// Brainstorming Node
async function brainstormNode(state: BlackboardStateType, agentId: string): Promise<Partial<BlackboardStateType>> {
  const agent = agents.find(a => a.id === agentId)
  if (!agent) throw new Error(`Agent ${agentId} not found`)

  console.log(`üí¨ ${agent.id} is contributing...`)
  const contribution = await agent.contribute(state)

  return {
    contributions: [
      ...state.contributions,
      {
        agentId: agent.id,
        timestamp: new Date(),
        content: contribution,
        upvotes: 0
      }
    ]
  }
}

// Synthesis Node (combines all perspectives)
async function synthesisNode(state: BlackboardStateType): Promise<Partial<BlackboardStateType>> {
  const prompt = `You are synthesizing a brainstorming session.

Topic: ${state.topic}

Contributions from agents:
${state.contributions
  .map(c => `**${c.agentId}** (${c.timestamp.toISOString()}):\n${c.content}`)
  .join('\n\n---\n\n')}

Your job:
1. Identify the strongest ideas from each perspective
2. Resolve contradictions (optimist vs pessimist)
3. Build a coherent action plan that balances all viewpoints

Provide final synthesis.`

  const response = await anthropic.messages.create({
    model: 'claude-4.5-sonnet',
    max_tokens: 3000,
    messages: [{ role: 'user', content: prompt }]
  })

  return {
    finalSynthesis: response.content[0].text
  }
}

// Build Swarm Workflow
const swarmWorkflow = new StateGraph(BlackboardState)

// Add brainstorming nodes for each agent
agents.forEach(agent => {
  swarmWorkflow.addNode(agent.id, async (state) => brainstormNode(state, agent.id))
})

swarmWorkflow.addNode('synthesis', synthesisNode)

// Connect agents in parallel (all run concurrently)
swarmWorkflow.setEntryPoint('optimist')
swarmWorkflow.addEdge('optimist', 'pessimist')
swarmWorkflow.addEdge('pessimist', 'pragmatist')
swarmWorkflow.addEdge('pragmatist', 'innovator')
swarmWorkflow.addEdge('innovator', 'synthesis')
swarmWorkflow.addEdge('synthesis', '__end__')

const swarmApp = swarmWorkflow.compile()

// Execute Swarm
const swarmResult = await swarmApp.invoke({
  topic: "Should we build a new AI-powered code review tool or improve our existing tool?",
  contributions: [],
  finalSynthesis: null
})

console.log('\nüìä Final Synthesis:')
console.log(swarmResult.finalSynthesis)

/* Example Output:

üí¨ optimist is contributing...
"A new tool could leapfrog competitors with modern AI capabilities. The market is hot for AI code review. We could capture 10% market share within a year."

üí¨ pessimist is contributing...
"Building from scratch means 18 months to feature parity with existing tool. We'll lose current customers who need immediate improvements. Risk of over-engineering."

üí¨ pragmatist is contributing...
"Improving existing tool: 3 months, $50K, keeps customers happy. New tool: 18 months, $500K, uncertain ROI. We have 6 months runway left."

üí¨ innovator is contributing...
"What if we build a plugin architecture? Existing tool gets AI plugins incrementally. Best of both: no rewrite, but modern capabilities. Ship in 6 weeks."

üìä Final Synthesis:
"Recommended approach: Plugin Architecture (innovator's proposal).

Rationale:
- Addresses pessimist's concern about losing customers (no migration required)
- Captures optimist's vision of AI capabilities (plugins enable cutting-edge features)
- Meets pragmatist's cost and timeline constraints (6 weeks vs 18 months)
- Enables innovator's unconventional approach (incremental AI adoption)

Action plan:
1. Month 1: Design plugin API and build 2 AI plugins (bug detection, security scanning)
2. Month 2-3: Launch plugins, gather feedback, iterate
3. Month 4-6: Expand plugin marketplace, enable third-party contributions

Cost: $75K (vs $500K for new tool)
Timeline: 6 months to full marketplace (vs 18 months for new tool)
Risk: Low (existing tool remains unchanged, plugins are additive)
"
*/
```

### Collaborative Swarms: Key Advantages

| Advantage | Why It Matters |
|-----------|----------------|
| **Parallel execution** | All agents contribute simultaneously (faster) |
| **Diverse perspectives** | No single point of failure in reasoning |
| **Emergent insights** | Synthesis finds ideas no single agent would generate |
| **Scalable** | Add/remove agents without changing workflow |

**Cost Analysis**:
```typescript
// Collaborative Swarm (4 agents + synthesis)
- 4 agent contributions: 4 √ó (500 input + 1000 output) = $0.096
- Synthesis: 3000 input + 2000 output = $0.039
- Total: $0.135

// Single agent brainstorm
- Cost: $0.025
- Quality: 70% (missing diverse perspectives, groupthink)

// Verdict: Swarms add 5.4x cost but prevent blind spots
```

---

## Supervisor vs. Swarms: Decision Matrix

| Factor | Supervisor | Collaborative Swarms |
|--------|------------|----------------------|
| **Coordination** | Manager controls everything | Agents self-coordinate |
| **Dependencies** | Sequential (Database ‚Üí Backend ‚Üí Frontend) | Parallel (all agents run at once) |
| **Quality control** | Manager validates each specialist | Synthesis resolves contradictions |
| **Best for** | Tasks requiring specialized skills | Tasks benefiting from diverse viewpoints |
| **Cost** | Higher (validation overhead) | Lower (no manager overhead) |
| **Latency** | Slower (sequential execution) | Faster (parallel execution) |

**Architect's Decision**:
- Use **Supervisor** for: Full-stack development, compliance workflows, production deployments
- Use **Swarms** for: Research, brainstorming, creative writing, decision analysis

---

## Key Takeaways

**Supervisor Pattern**:
- Manager agent routes tasks to specialists and validates output
- Feedback loops allow specialists to revise (up to 3 attempts)
- Sequential execution respects dependencies (database before backend)
- Cost: 4x single-prompt, but prevents production bugs

**Collaborative Swarms**:
- Decentralized agents share state via Blackboard
- Parallel execution accelerates brainstorming
- Synthesis agent combines diverse perspectives
- Cost: 5.4x single-prompt, but eliminates blind spots

**The Architect's Responsibility**:
You **own** the orchestration strategy. If your Supervisor's manager doesn't validate specialist output, **you'll ship bugs**. If your Swarm agents all provide identical perspectives, **you wasted parallel execution**. If you use Swarms for sequential tasks (database schema must precede API routes), **you'll get broken integrations**.

**Cost Comparison**:
```typescript
// Single monolithic agent
- Cost: $0.05
- Quality: 60%
- Architect verdict: ‚ùå Production risk

// Supervisor (Manager + 3 specialists + validation)
- Cost: $0.204
- Quality: 95%
- Use case: Full-stack development
- Architect verdict: ‚úÖ Production-ready for specialized tasks

// Collaborative Swarm (4 agents + synthesis)
- Cost: $0.135
- Quality: 90%
- Use case: Brainstorming and research
- Architect verdict: ‚úÖ Production-ready for creative tasks
```

**Next Concept**: Now that you can orchestrate teams of agents, Concept 3 covers **Reliability Patterns** (Self-Reflection and Human-in-the-Loop) to harden non-deterministic systems for enterprise deployment.
