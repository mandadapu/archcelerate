# Agent Debugging and Observability

Learn how to debug AI agents, understand failure modes, and build observability into your agent systems.

## Why Agent Debugging is Different

Debugging agents is harder than debugging traditional code because:

1. **Non-deterministic behavior**: Same input can produce different outputs
2. **Multi-step reasoning**: Failures can compound across steps
3. **Tool interactions**: Bugs can be in tools, agent logic, or their interaction
4. **Context-dependent**: Small prompt changes can drastically change behavior
5. **Emergent failures**: Problems appear only with certain input combinations

Traditional debugging tools (breakpoints, stack traces) don't work well for agents. You need specialized techniques.

## Common Agent Failure Modes

### 1. Infinite Loops

**What happens**: Agent gets stuck repeating the same action forever.

**Example**:
```
Step 1: search_web("current time")
Observation: "Search results for current time"

Step 2: search_web("current time")
Observation: "Search results for current time"

Step 3: search_web("current time")
[continues forever...]
```

**Why it happens**:
- Tool returns unhelpful result, agent doesn't recognize it
- Agent doesn't realize the action failed
- No variety in problem-solving approach

**How to fix**:
```typescript
class AgentExecutor {
  private actionHistory: Array<{ tool: string; input: string }> = []

  async executeStep(action: Action) {
    // Detect repeated actions
    const lastThreeActions = this.actionHistory.slice(-3)
    const repeating = lastThreeActions.every(
      a => a.tool === action.tool && JSON.stringify(a.input) === JSON.stringify(action.input)
    )

    if (repeating) {
      return {
        observation: `Error: You've tried "${action.tool}" with the same input 3 times. This approach isn't working. Try a different tool or approach.`,
        shouldStop: true
      }
    }

    // Record action
    this.actionHistory.push({ tool: action.tool, input: action.input })

    // Execute normally
    return await this.runTool(action)
  }
}
```

### 2. Hallucinated Tools

**What happens**: Agent tries to use tools that don't exist.

**Example**:
```
Agent: I'll use the "get_real_time_data" tool
Error: Tool "get_real_time_data" not found
```

**Why it happens**:
- Agent invents plausible-sounding tool names
- Tool descriptions are unclear
- Agent misremembers available tools

**How to fix**:
```typescript
async function validateToolCall(toolName: string, availableTools: Tool[]): Promise<string | null> {
  const tool = availableTools.find(t => t.name === toolName)

  if (!tool) {
    const available = availableTools.map(t => t.name).join(', ')
    return `Error: Tool "${toolName}" does not exist. Available tools: ${available}. Please choose from the available tools only.`
  }

  return null // Valid tool
}

// In your agent loop
const validationError = await validateToolCall(action.tool, this.tools)
if (validationError) {
  return { observation: validationError }
}
```

### 3. Wrong Tool Selection

**What happens**: Agent chooses the wrong tool for the task.

**Example**:
```
User: "What's the weather in Paris?"
Agent: Uses "calculator" tool instead of "get_weather"
```

**Why it happens**:
- Tool descriptions are too vague or too similar
- Agent misunderstands the task
- Tool names are confusing

**How to fix**:
```typescript
// Bad: Vague, overlapping descriptions
const tools = [
  { name: 'search', description: 'Search for things' },
  { name: 'query', description: 'Query stuff' },
  { name: 'find', description: 'Find information' }
]

// Good: Distinct, specific descriptions
const tools = [
  {
    name: 'search_web',
    description: 'Search the internet for current news, articles, and general information. Use when you need up-to-date information not in your knowledge base.'
  },
  {
    name: 'search_database',
    description: 'Search the internal product database for SKUs, prices, and inventory. Use when users ask about products, prices, or stock availability.'
  },
  {
    name: 'search_documents',
    description: 'Search company documentation and knowledge base articles. Use for internal policies, procedures, or technical documentation.'
  }
]
```

### 4. Ignoring Tool Results

**What happens**: Agent gets a result but doesn't use it properly.

**Example**:
```
Step 1: get_weather("Paris")
Observation: "Temperature: 18째C, Cloudy"

Agent: "I don't have access to real-time weather data."
```

**Why it happens**:
- Agent doesn't recognize the observation as an answer
- Tool output format is unclear
- Agent reasoning is flawed

**How to fix**:
```typescript
// Bad: Unclear format
return "18"

// Good: Clear, structured format
return JSON.stringify({
  status: 'success',
  data: {
    location: 'Paris',
    temperature: '18째C',
    conditions: 'Cloudy'
  }
})

// Even better: Natural language + structure
return `Weather data retrieved successfully:
Location: Paris, France
Temperature: 18째C (64째F)
Conditions: Cloudy
Humidity: 65%
Wind: 12 km/h

This is current, real-time weather data.`
```

### 5. Premature Termination

**What happens**: Agent gives up too early or provides incomplete answers.

**Example**:
```
User: "Find the best Italian restaurant in Boston and make a reservation"

Step 1: search_restaurants("Italian restaurant Boston")
Observation: "Found 10 Italian restaurants"

Agent: "I found some Italian restaurants in Boston."
[Stops without ranking them or making reservation]
```

**Why it happens**:
- Agent doesn't plan multi-step tasks
- No explicit goal tracking
- Agent thinks task is complete when it's not

**How to fix**:
```typescript
interface AgentConfig {
  systemPrompt: string
  requiresExplicitCompletion: boolean
}

const systemPrompt = `You are a task-completion agent. For each user request:

1. Break down the task into all required steps
2. Complete EVERY step before responding
3. Only say you're done when the ENTIRE task is complete
4. If you can't complete a step, explain why and what you tried

Example:
User: "Find the best Italian restaurant in Boston and make a reservation"
Required steps:
1. Search for Italian restaurants in Boston
2. Compare ratings and reviews
3. Select the best option
4. Make a reservation at that restaurant
5. Confirm reservation details to user

Do NOT stop after step 1 or 2. Complete the full task.`
```

## Observability: Logging Thoughts, Actions, and Observations

The key to debugging agents is **visibility**. You need to see what the agent is thinking and doing.

### Basic Logging

```typescript
interface AgentStep {
  stepNumber: number
  timestamp: Date
  thought: string
  action: {
    tool: string
    input: any
  }
  observation: string
  cost: {
    inputTokens: number
    outputTokens: number
    totalCost: number
  }
}

class ObservableAgent {
  private steps: AgentStep[] = []

  async run(userQuery: string) {
    console.log('='.repeat(60))
    console.log(`[AGENT START] Query: "${userQuery}"`)
    console.log(`[TIMESTAMP] ${new Date().toISOString()}`)
    console.log('='.repeat(60))

    let stepNumber = 0

    while (stepNumber < this.maxSteps) {
      stepNumber++

      // Get agent's thought
      const response = await this.callLLM(userQuery, this.steps)

      const thought = this.extractThought(response)
      console.log(`\n[STEP ${stepNumber}] Thought:`)
      console.log(`  ${thought}`)

      // Get action
      const action = this.extractAction(response)
      console.log(`\n[STEP ${stepNumber}] Action:`)
      console.log(`  Tool: ${action.tool}`)
      console.log(`  Input: ${JSON.stringify(action.input, null, 2)}`)

      // Execute tool
      const startTime = Date.now()
      const observation = await this.executeTool(action)
      const duration = Date.now() - startTime

      console.log(`\n[STEP ${stepNumber}] Observation:`)
      console.log(`  Duration: ${duration}ms`)
      console.log(`  Result: ${observation.substring(0, 200)}${observation.length > 200 ? '...' : ''}`)

      // Calculate cost
      const cost = this.calculateCost(response)
      console.log(`\n[STEP ${stepNumber}] Cost:`)
      console.log(`  Input tokens: ${cost.inputTokens}`)
      console.log(`  Output tokens: ${cost.outputTokens}`)
      console.log(`  Cost: $${cost.totalCost.toFixed(4)}`)

      // Record step
      this.steps.push({
        stepNumber,
        timestamp: new Date(),
        thought,
        action,
        observation,
        cost
      })

      // Check for completion
      if (action.tool === 'final_answer') {
        console.log('\n' + '='.repeat(60))
        console.log('[AGENT COMPLETE]')
        console.log(`Total steps: ${stepNumber}`)
        console.log(`Total cost: $${this.getTotalCost().toFixed(4)}`)
        console.log('='.repeat(60))
        return observation
      }
    }

    throw new Error('Agent exceeded maximum steps')
  }

  private getTotalCost(): number {
    return this.steps.reduce((sum, step) => sum + step.cost.totalCost, 0)
  }
}
```

### Structured Logging with Tracing

```typescript
import { trace } from '@opentelemetry/api'

class TracedAgent {
  private tracer = trace.getTracer('ai-agent')

  async run(userQuery: string) {
    return this.tracer.startActiveSpan('agent.run', async (span) => {
      span.setAttribute('query', userQuery)

      try {
        const result = await this.executeAgent(userQuery)
        span.setAttribute('result', result)
        span.setStatus({ code: 0 }) // Success
        return result
      } catch (error) {
        span.setStatus({ code: 2, message: error.message }) // Error
        span.recordException(error)
        throw error
      } finally {
        span.end()
      }
    })
  }

  private async executeStep(action: Action) {
    return this.tracer.startActiveSpan('agent.step', async (span) => {
      span.setAttribute('tool', action.tool)
      span.setAttribute('input', JSON.stringify(action.input))

      const startTime = Date.now()
      const observation = await this.executeTool(action)
      const duration = Date.now() - startTime

      span.setAttribute('duration_ms', duration)
      span.setAttribute('observation_length', observation.length)

      return observation
    })
  }
}
```

## Debugging Techniques

### 1. Step-by-Step Traces

Create a visual trace of agent execution:

```typescript
class DebugAgent {
  async run(userQuery: string) {
    const trace = {
      query: userQuery,
      steps: [],
      result: null,
      totalCost: 0,
      totalDuration: 0
    }

    const startTime = Date.now()

    try {
      // Execute agent
      trace.result = await this.execute(userQuery, trace.steps)
      trace.totalDuration = Date.now() - startTime
      trace.totalCost = this.calculateTotalCost(trace.steps)

      // Generate HTML trace viewer
      await this.generateTraceHTML(trace)

      return trace.result
    } catch (error) {
      trace.error = error.message
      await this.generateTraceHTML(trace)
      throw error
    }
  }

  private async generateTraceHTML(trace: any) {
    const html = `
<!DOCTYPE html>
<html>
<head>
  <title>Agent Trace: ${trace.query}</title>
  <style>
    body { font-family: monospace; max-width: 1200px; margin: 20px auto; }
    .step { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }
    .thought { background: #e3f2fd; padding: 8px; }
    .action { background: #fff3e0; padding: 8px; }
    .observation { background: #e8f5e9; padding: 8px; }
    .error { background: #ffebee; padding: 8px; }
  </style>
</head>
<body>
  <h1>Agent Trace</h1>
  <div><strong>Query:</strong> ${trace.query}</div>
  <div><strong>Duration:</strong> ${trace.totalDuration}ms</div>
  <div><strong>Cost:</strong> $${trace.totalCost.toFixed(4)}</div>

  ${trace.steps.map((step, i) => `
    <div class="step">
      <h3>Step ${i + 1}</h3>
      <div class="thought"><strong>Thought:</strong> ${step.thought}</div>
      <div class="action"><strong>Action:</strong> ${step.action.tool}(${JSON.stringify(step.action.input)})</div>
      <div class="observation"><strong>Observation:</strong> ${step.observation}</div>
    </div>
  `).join('')}

  ${trace.error ? `<div class="error"><strong>Error:</strong> ${trace.error}</div>` : ''}
  ${trace.result ? `<div><strong>Result:</strong> ${trace.result}</div>` : ''}
</body>
</html>`

    await writeFile(`./traces/trace-${Date.now()}.html`, html)
  }
}
```

### 2. Cost Tracking

Monitor and alert on excessive costs:

```typescript
class CostAwareAgent {
  private costLimit: number = 1.0 // $1 per query max
  private totalCost: number = 0

  async executeStep(action: Action) {
    // Estimate cost before executing
    const estimatedCost = this.estimateStepCost(action)

    if (this.totalCost + estimatedCost > this.costLimit) {
      throw new Error(
        `Cost limit exceeded. Current: $${this.totalCost.toFixed(4)}, ` +
        `Estimated next: $${estimatedCost.toFixed(4)}, ` +
        `Limit: $${this.costLimit}`
      )
    }

    const result = await this.executeTool(action)

    // Track actual cost
    const actualCost = this.calculateActualCost(result)
    this.totalCost += actualCost

    console.log(`[COST] Step cost: $${actualCost.toFixed(4)}, Total: $${this.totalCost.toFixed(4)}`)

    return result
  }

  private estimateStepCost(action: Action): number {
    // Estimate based on average token usage
    const avgInputTokens = 500
    const avgOutputTokens = 200

    // Claude 3.5 Sonnet pricing (example)
    const inputCostPer1k = 0.003
    const outputCostPer1k = 0.015

    return (
      (avgInputTokens / 1000) * inputCostPer1k +
      (avgOutputTokens / 1000) * outputCostPer1k
    )
  }
}
```

### 3. Assertion-Based Testing

Test specific agent behaviors:

```typescript
import { describe, it, expect } from 'vitest'

describe('WeatherAgent', () => {
  it('should use get_weather tool for weather queries', async () => {
    const agent = new DebugAgent()
    const trace = []

    await agent.run('What is the weather in London?', trace)

    // Assert the agent used the weather tool
    const usedTools = trace.map(step => step.action.tool)
    expect(usedTools).toContain('get_weather')
  })

  it('should not make more than 5 steps for simple queries', async () => {
    const agent = new DebugAgent()
    const trace = []

    await agent.run('What is 2+2?', trace)

    expect(trace.length).toBeLessThanOrEqual(5)
  })

  it('should handle tool failures gracefully', async () => {
    const agent = new DebugAgent()
    const trace = []

    // Mock tool failure
    agent.tools.find(t => t.name === 'search_web').execute = async () => {
      throw new Error('Network timeout')
    }

    const result = await agent.run('Search for latest news', trace)

    // Agent should try alternative approach or acknowledge failure
    expect(result).toBeTruthy()
    expect(trace.some(s => s.observation.includes('Error'))).toBe(true)
  })
})
```

## Testing Strategies for Agents

### 1. Unit Test Individual Tools

```typescript
describe('weatherTool', () => {
  it('returns valid weather data', async () => {
    const result = await weatherTool.execute({ location: 'Paris' })
    expect(result).toContain('Temperature:')
    expect(result).toContain('Paris')
  })

  it('handles invalid locations', async () => {
    const result = await weatherTool.execute({ location: 'InvalidCity123' })
    expect(result).toContain('Error')
  })
})
```

### 2. Integration Test Tool Combinations

```typescript
describe('TravelAgent', () => {
  it('should plan a complete trip', async () => {
    const agent = new TravelAgent()
    const result = await agent.run(
      'Plan a 3-day trip to Tokyo with flights from NYC and hotel under $200/night'
    )

    // Verify all required information is present
    expect(result).toContain('flight')
    expect(result).toContain('hotel')
    expect(result).toContain('total cost')
  })
})
```

### 3. Regression Tests for Known Failures

```typescript
describe('Agent Regression Tests', () => {
  it('should not enter infinite loop on ambiguous queries', async () => {
    const agent = new DebugAgent({ maxSteps: 20 })

    // This query previously caused infinite loops
    const result = await agent.run('Tell me something interesting')

    // Should complete within step limit
    expect(result).toBeTruthy()
  })

  it('should not hallucinate tools', async () => {
    const agent = new DebugAgent()
    const trace = []

    await agent.run('What time is it?', trace)

    // All tools used should be in available tools
    const availableToolNames = agent.tools.map(t => t.name)
    const usedTools = trace.map(s => s.action.tool)

    usedTools.forEach(tool => {
      expect(availableToolNames).toContain(tool)
    })
  })
})
```

### 4. Golden Tests (Snapshot Testing)

```typescript
describe('Agent Golden Tests', () => {
  it('produces consistent output for standard queries', async () => {
    const agent = new Agent({ temperature: 0 }) // Deterministic mode

    const queries = [
      'What is 2+2?',
      'What is the capital of France?',
      'Convert 100 USD to EUR'
    ]

    for (const query of queries) {
      const result = await agent.run(query)
      expect(result).toMatchSnapshot()
    }
  })
})
```

## Monitoring Agent Behavior in Production

### 1. Real-Time Monitoring Dashboard

```typescript
class ProductionAgent {
  async run(userQuery: string) {
    const metrics = {
      startTime: Date.now(),
      query: userQuery,
      steps: 0,
      cost: 0,
      errors: [],
      toolsUsed: []
    }

    try {
      const result = await this.execute(userQuery, metrics)

      // Send to monitoring service
      await this.sendMetrics({
        ...metrics,
        duration: Date.now() - metrics.startTime,
        status: 'success',
        result
      })

      return result
    } catch (error) {
      metrics.errors.push(error.message)

      await this.sendMetrics({
        ...metrics,
        duration: Date.now() - metrics.startTime,
        status: 'error',
        error: error.message
      })

      throw error
    }
  }

  private async sendMetrics(metrics: any) {
    // Send to DataDog, Prometheus, CloudWatch, etc.
    await fetch('https://monitoring.example.com/metrics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        timestamp: new Date().toISOString(),
        service: 'ai-agent',
        ...metrics
      })
    })
  }
}
```

### 2. Alerting on Anomalies

```typescript
class MonitoredAgent {
  private alertThresholds = {
    maxSteps: 15,
    maxCost: 0.50,
    maxDuration: 30000, // 30 seconds
    errorRate: 0.1 // 10%
  }

  async execute(query: string) {
    const result = await this.run(query)

    // Check thresholds
    if (result.steps > this.alertThresholds.maxSteps) {
      await this.alert({
        type: 'excessive_steps',
        query,
        steps: result.steps,
        threshold: this.alertThresholds.maxSteps
      })
    }

    if (result.cost > this.alertThresholds.maxCost) {
      await this.alert({
        type: 'excessive_cost',
        query,
        cost: result.cost,
        threshold: this.alertThresholds.maxCost
      })
    }

    return result
  }

  private async alert(alert: any) {
    console.error('[ALERT]', alert)

    // Send to PagerDuty, Slack, email, etc.
    await fetch('https://alerts.example.com/alert', {
      method: 'POST',
      body: JSON.stringify(alert)
    })
  }
}
```

### 3. Logging and Analytics

```typescript
class AnalyticsAgent {
  async run(userQuery: string, userId: string) {
    const sessionId = generateId()

    // Log query
    await this.logEvent({
      event: 'agent_query',
      sessionId,
      userId,
      query: userQuery,
      timestamp: new Date()
    })

    const steps = []
    const result = await this.execute(userQuery, steps)

    // Log each step
    for (const step of steps) {
      await this.logEvent({
        event: 'agent_step',
        sessionId,
        userId,
        stepNumber: step.stepNumber,
        tool: step.action.tool,
        duration: step.duration,
        timestamp: step.timestamp
      })
    }

    // Log completion
    await this.logEvent({
      event: 'agent_complete',
      sessionId,
      userId,
      totalSteps: steps.length,
      totalCost: this.calculateCost(steps),
      result,
      timestamp: new Date()
    })

    return result
  }

  private async logEvent(event: any) {
    // Send to analytics platform (Mixpanel, Amplitude, etc.)
    await analyticsClient.track(event)
  }
}
```

## Debugging Checklist

When your agent misbehaves, work through this checklist:

### 1. Check Tool Definitions
- [ ] Are tool descriptions clear and specific?
- [ ] Are parameter schemas correct?
- [ ] Do tools have good examples in descriptions?

### 2. Check Tool Execution
- [ ] Do tools return structured, parseable results?
- [ ] Do tools handle errors gracefully (return error strings, don't throw)?
- [ ] Are tool outputs concise (not too long)?

### 3. Check Agent Loop
- [ ] Is there a maximum step limit?
- [ ] Is there infinite loop detection?
- [ ] Is tool validation happening?

### 4. Check Context Management
- [ ] Is conversation history included in prompts?
- [ ] Are tool results being added to context?
- [ ] Is context within token limits?

### 5. Check System Prompt
- [ ] Is the agent's role clear?
- [ ] Are instructions specific enough?
- [ ] Are there examples of good behavior?

### 6. Check Logs
- [ ] Can you see each thought, action, observation?
- [ ] Are timestamps and costs tracked?
- [ ] Can you replay the execution?

## Summary

In this lesson, you learned:

- Common agent failure modes (infinite loops, hallucinated tools, wrong tool selection)
- How to add observability through logging and tracing
- Debugging techniques (step-by-step traces, cost tracking, assertions)
- Testing strategies for agents (unit tests, integration tests, regression tests)
- How to monitor agent behavior in production
- A debugging checklist for troubleshooting

Debugging agents requires visibility. The more you can see what your agent is thinking and doing, the easier it is to identify and fix problems.

## Further Reading

- [Anthropic Debugging Guide](https://docs.anthropic.com/claude/docs/debugging)
- [OpenTelemetry for AI/ML](https://opentelemetry.io/docs/)
- [Testing LLM Applications](https://hamel.dev/blog/posts/testing/)
- [Agent Observability Best Practices](https://www.anthropic.com/index/building-effective-agents)
