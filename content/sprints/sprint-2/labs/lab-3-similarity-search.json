{
  "id": "lab-3-similarity-search",
  "title": "Similarity Search Exercise",
  "description": "Implement cosine similarity and semantic search",
  "difficulty": "advanced",
  "estimatedMinutes": 45,
  "language": "javascript",
  "starterCode": "/**\n * Calculate cosine similarity between two vectors\n * @param {number[]} vecA - First vector\n * @param {number[]} vecB - Second vector\n * @returns {number} - Similarity score between -1 and 1\n */\nfunction cosineSimilarity(vecA, vecB) {\n  // Your code here\n  return 0\n}\n\n/**\n * Find top-k most similar chunks to query\n * @param {number[]} queryEmbedding - Query vector\n * @param {Array<{content: string, embedding: number[]}>} chunks - Document chunks\n * @param {number} k - Number of results to return\n * @returns {Array<{content: string, similarity: number}>} - Top-k results\n */\nfunction findSimilar(queryEmbedding, chunks, k = 5) {\n  // Your code here\n  return []\n}\n",
  "instructions": "Implement:\n1. `cosineSimilarity(vecA, vecB)`: Calculate cosine similarity\n   - Formula: (A · B) / (||A|| × ||B||)\n   - Dot product divided by product of magnitudes\n   - Returns value between -1 (opposite) and 1 (identical)\n\n2. `findSimilar(queryEmbedding, chunks, k)`: Search for similar chunks\n   - Calculate similarity between query and each chunk\n   - Sort by similarity (highest first)\n   - Return top-k results with content and similarity score",
  "testCases": [
    {
      "input": "cosineSimilarity([1, 0, 0], [1, 0, 0])",
      "expectedOutput": "1",
      "description": "Identical vectors have similarity 1"
    },
    {
      "input": "cosineSimilarity([1, 0], [0, 1])",
      "expectedOutput": "0",
      "description": "Orthogonal vectors have similarity 0"
    },
    {
      "input": "findSimilar([1, 0], [{content: 'a', embedding: [1, 0]}, {content: 'b', embedding: [0, 1]}], 1)[0].content",
      "expectedOutput": "a",
      "description": "Returns most similar chunk"
    }
  ],
  "hints": [
    "Dot product: vecA.reduce((sum, a, i) => sum + a * vecB[i], 0)",
    "Magnitude: Math.sqrt(vec.reduce((sum, x) => sum + x*x, 0))",
    "Use map() to calculate similarities, then sort() and slice(0, k)",
    "Sort descending: (a, b) => b.similarity - a.similarity"
  ]
}
