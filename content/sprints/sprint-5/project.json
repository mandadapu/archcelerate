{
  "id": "production-ai-api",
  "title": "Production-Ready AI API with Monitoring & Optimization",
  "description": "Build a production-grade AI API that combines rate limiting, semantic caching, monitoring, retry logic, and cost tracking for reliable, scalable AI applications",
  "difficulty": "advanced",
  "estimatedHours": 5,
  "technologies": ["Next.js", "Claude API", "Redis", "Sentry", "Upstash", "TypeScript", "Vercel"],
  "learningObjectives": [
    "Implement production-grade rate limiting",
    "Build semantic caching with embeddings",
    "Integrate comprehensive monitoring with Sentry",
    "Create retry logic with exponential backoff",
    "Design admin dashboard for API analytics",
    "Implement cost tracking and budget alerts",
    "Build health check and status endpoints",
    "Handle graceful degradation and fallbacks"
  ],
  "requirements": {
    "functional": [
      "AI chat API with streaming support",
      "Rate limiting per user/IP (10 req/min, 100 req/hour)",
      "Semantic cache for similar queries (90%+ similarity)",
      "Retry logic with exponential backoff (3 attempts)",
      "Cost tracking with budget alerts",
      "Admin dashboard for monitoring metrics",
      "Health check endpoint (/api/health)",
      "Error handling with graceful fallbacks",
      "Analytics for cache hit rate, latency, costs",
      "API key management for different tiers"
    ],
    "technical": [
      "Use Upstash Redis for rate limiting and caching",
      "Implement semantic similarity with embeddings",
      "Integrate Sentry for error tracking and performance",
      "Build retry middleware with circuit breaker",
      "Store metrics in Redis with time-series data",
      "Implement cost calculation per request",
      "Use middleware for rate limiting checks",
      "Cache embeddings with 24-hour TTL",
      "Log all API calls with metadata",
      "Implement request/response validation"
    ],
    "ui": [
      "Chat interface with rate limit display",
      "Cache hit indicators",
      "Admin dashboard with key metrics",
      "Real-time cost tracker",
      "Error message with retry countdown",
      "Health status page",
      "API analytics charts (requests, latency, costs)",
      "Budget alert notifications",
      "Rate limit warning banners",
      "Loading states with retry indicators"
    ]
  },
  "successCriteria": [
    {
      "criterion": "Production Reliability",
      "description": "Rate limiting works, retries handle failures, 99%+ uptime",
      "weight": 30
    },
    {
      "criterion": "Caching Effectiveness",
      "description": "Semantic cache achieves 40%+ hit rate, reduces costs",
      "weight": 25
    },
    {
      "criterion": "Monitoring & Observability",
      "description": "Sentry tracks errors, dashboard shows metrics, alerts work",
      "weight": 20
    },
    {
      "criterion": "Cost Optimization",
      "description": "Cost tracking accurate, budgets enforced, caching saves money",
      "weight": 15
    },
    {
      "criterion": "Code Quality & UX",
      "description": "Clean architecture, proper error handling, polished UI",
      "weight": 10
    }
  ],
  "testScenarios": [
    "Send 15 requests in 1 minute - verify rate limiting kicks in",
    "Ask same question 3 times - verify cache hits and cost savings",
    "Ask similar questions - verify semantic cache works (90%+ similarity)",
    "Trigger API failure - verify retry logic with exponential backoff",
    "Exceed budget limit - verify request blocking and alerts",
    "Monitor dashboard - verify metrics update in real-time",
    "Check /api/health - verify all services are healthy",
    "Trigger errors - verify Sentry captures and reports them",
    "Test concurrent requests - verify performance under load",
    "Review cost breakdown - verify accurate token counting"
  ],
  "starterFiles": {
    "structure": [
      "app/api/chat/route.ts",
      "app/api/health/route.ts",
      "app/api/admin/metrics/route.ts",
      "app/api/admin/costs/route.ts",
      "middleware.ts",
      "lib/rate-limiter.ts",
      "lib/semantic-cache.ts",
      "lib/retry-handler.ts",
      "lib/cost-tracker.ts",
      "lib/monitoring.ts",
      "lib/embeddings.ts",
      "lib/redis-client.ts",
      "components/ChatInterface.tsx",
      "components/AdminDashboard.tsx",
      "components/MetricsChart.tsx",
      "components/CostTracker.tsx",
      "components/HealthStatus.tsx",
      "types/metrics.ts",
      "types/api.ts"
    ]
  },
  "technicalGuidance": {
    "rateLimiting": "Use sliding window algorithm in Redis, track by IP + user ID, implement tier-based limits (free: 10/min, pro: 100/min)",
    "semanticCaching": "Generate embeddings for queries (text-embedding-3-small), compute cosine similarity, cache responses with 90%+ similarity threshold, 24h TTL",
    "monitoring": "Sentry for errors + performance, custom metrics in Redis (request count, latency p50/p95/p99, cache hit rate, costs), real-time dashboard updates",
    "retryLogic": "Exponential backoff (1s, 2s, 4s), max 3 attempts, circuit breaker after 5 consecutive failures, different strategies for rate limits vs server errors",
    "costTracking": "Track input/output tokens per request, calculate costs (Claude 3.5 Sonnet: $3/$15 per 1M tokens), store daily/monthly aggregates, alert at 80% budget",
    "caching": "Multi-layer: 1) Exact match (hash-based), 2) Semantic (embedding similarity), 3) Embedding cache (avoid re-embedding same queries)",
    "healthChecks": "Check Redis connectivity, Claude API status, Sentry integration, cache performance, return detailed status + metrics",
    "errorHandling": "Graceful degradation (disable cache if Redis fails), fallback responses, user-friendly error messages, automatic recovery"
  },
  "deploymentRequirements": {
    "platform": "Vercel",
    "environment": [
      "ANTHROPIC_API_KEY",
      "UPSTASH_REDIS_URL",
      "UPSTASH_REDIS_TOKEN",
      "SENTRY_DSN",
      "SENTRY_AUTH_TOKEN",
      "NEXT_PUBLIC_SENTRY_DSN",
      "ADMIN_API_KEY (for dashboard access)",
      "BUDGET_LIMIT_USD (default: 100)"
    ],
    "instructions": "Deploy to Vercel, configure all environment variables, set up Sentry project, create Upstash Redis database, enable edge runtime for rate limiting, configure CORS for admin dashboard"
  },
  "estimatedCosts": {
    "development": {
      "claude": "$2.00 (testing with ~100 requests)",
      "redis": "$0 (Upstash free tier: 10K requests/day)",
      "sentry": "$0 (free tier: 5K events/month)",
      "embeddings": "$0.10 (text-embedding-3-small)",
      "total": "$2.10"
    },
    "production": {
      "claude": "$20/month (1000 requests with 40% cache hit = 600 API calls)",
      "redis": "$0 (stays in free tier for moderate usage)",
      "sentry": "$0-26/month (free tier usually sufficient)",
      "embeddings": "$1/month (caching reduces embedding calls)",
      "total": "$21-47/month (depending on scale)"
    },
    "savings": {
      "withoutCaching": "$35/month (1000 uncached requests)",
      "withCaching": "$20/month (40% hit rate)",
      "monthlySavings": "$15/month (43% reduction)",
      "note": "Higher cache hit rates yield greater savings"
    }
  },
  "extensionIdeas": [
    "Add multiple AI model support with automatic fallback (Claude -> GPT-4 -> GPT-3.5)",
    "Implement A/B testing for different caching strategies",
    "Build API key management with usage-based billing",
    "Add webhook notifications for budget alerts and errors",
    "Implement request queueing for rate-limited users",
    "Build analytics export (CSV/JSON) for cost analysis",
    "Add custom domains with SSL for enterprise deployments",
    "Implement request prioritization (premium users first)",
    "Build GraphQL API alongside REST endpoints",
    "Add distributed tracing with OpenTelemetry",
    "Implement feature flags for gradual rollouts",
    "Build user dashboard for personal usage analytics",
    "Add geolocation-based routing for lower latency",
    "Implement API versioning with backward compatibility"
  ],
  "rubric": {
    "exceeds": "All features work flawlessly, cache hit rate >50%, comprehensive monitoring with Sentry, admin dashboard is polished, retry logic handles all edge cases, costs accurately tracked with alerts, documentation is excellent, deployed and stable",
    "meets": "Rate limiting works, semantic cache achieves 40%+ hit rate, Sentry captures errors, admin dashboard shows key metrics, retry logic handles common failures, cost tracking is accurate, health checks work, deployed successfully",
    "approaching": "Basic rate limiting works, cache has some hits but <40%, monitoring is partial, retry logic works for simple cases, cost tracking exists but has gaps, some features missing or buggy",
    "incomplete": "Rate limiting broken, no caching or <20% hit rate, no monitoring, retry logic doesn't work, cost tracking missing, or not deployed"
  }
}
