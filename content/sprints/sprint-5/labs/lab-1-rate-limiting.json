{
  "id": "lab-1-rate-limiting",
  "title": "Build Redis-Based Rate Limiter",
  "description": "Implement a production-ready rate limiter using Redis and sliding window algorithm to protect AI API endpoints from abuse and manage API costs",
  "difficulty": "intermediate",
  "estimatedMinutes": 180,
  "language": "typescript",
  "starterCode": "// Rate limiter implementation\nimport { Redis } from '@upstash/redis'\n\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL!,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n})\n\nexport type RateLimitTier = 'free' | 'pro' | 'enterprise'\n\nexport interface RateLimitConfig {\n  requests: number\n  window: number // in seconds\n}\n\nconst RATE_LIMITS: Record<RateLimitTier, RateLimitConfig> = {\n  free: { requests: 10, window: 60 },\n  pro: { requests: 100, window: 60 },\n  enterprise: { requests: 1000, window: 60 },\n}\n\nexport interface RateLimitResult {\n  success: boolean\n  limit: number\n  remaining: number\n  reset: number\n}\n\nexport async function checkRateLimit(\n  identifier: string,\n  tier: RateLimitTier = 'free'\n): Promise<RateLimitResult> {\n  // TODO: Implement sliding window rate limiter\n  // 1. Get current timestamp\n  // 2. Create Redis key: `ratelimit:${identifier}`\n  // 3. Use sorted set to track requests in window\n  // 4. Remove old requests outside window\n  // 5. Count requests in current window\n  // 6. Add current request if under limit\n  // 7. Return result with limit info\n  \n  return {\n    success: true,\n    limit: 0,\n    remaining: 0,\n    reset: 0,\n  }\n}",
  "instructions": "Implement a production-ready rate limiter using Redis and sliding window algorithm.\n\n**Objectives:**\n- Implement sliding window rate limiter using Redis sorted sets\n- Support multiple rate limit tiers (free: 10/min, pro: 100/min, enterprise: 1000/min)\n- Return proper rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset)\n- Handle rate limit exceeded with 429 status and retry-after header\n- Integrate with AI API endpoints\n\n**Implementation Steps:**\n\n1. **Implement checkRateLimit function:**\n   - Get current timestamp using Date.now()\n   - Create Redis key: `ratelimit:${identifier}`\n   - Use Redis sorted set (ZSET) to track requests\n   - Remove old requests outside window using ZREMRANGEBYSCORE\n   - Count current requests with ZCARD\n   - If under limit, add current request with ZADD\n   - Set TTL on key using EXPIRE (2x window duration)\n   - Return RateLimitResult with success, limit, remaining, reset\n\n2. **Create AI API endpoint with rate limiting:**\n   - Get user identifier (user ID or IP address)\n   - Determine user's tier from database/session\n   - Call checkRateLimit with identifier and tier\n   - If exceeded, return 429 with headers and retry-after\n   - If allowed, process AI request\n   - Add rate limit headers to response\n\n3. **Add rate limiting middleware:**\n   - Apply rate limiting to API routes\n   - Extract user identifier from request\n   - Check rate limit before processing\n   - Return response with rate limit headers\n\n**Technical Requirements:**\n- Use Upstash Redis for distributed rate limiting\n- Implement atomic Redis operations for accuracy\n- Handle concurrent requests correctly\n- Add comprehensive error handling for Redis failures\n\n**Testing:**\n- Test with requests within limit (should all succeed)\n- Test exceeding limit (11th request should return 429)\n- Test different tiers have different limits\n- Test rate limit resets after time window\n- Test concurrent requests counted accurately",
  "testCases": [
    {
      "name": "User stays within rate limit",
      "input": {
        "requests": 5,
        "tier": "free"
      },
      "expected": {
        "allSucceed": true,
        "remainingRequests": 5
      }
    },
    {
      "name": "User exceeds rate limit",
      "input": {
        "requests": 11,
        "tier": "free"
      },
      "expected": {
        "firstTenSucceed": true,
        "eleventhStatus": 429,
        "hasRetryAfterHeader": true
      }
    },
    {
      "name": "Different tiers have different limits",
      "input": {
        "requests": 50,
        "freeTier": "free",
        "proTier": "pro"
      },
      "expected": {
        "freeTierBlocked": true,
        "proTierAllSucceed": true
      }
    },
    {
      "name": "Rate limit resets after time window",
      "input": {
        "exhaustLimit": 10,
        "waitSeconds": 60
      },
      "expected": {
        "requestAfterWaitSucceeds": true
      }
    },
    {
      "name": "Concurrent requests counted accurately",
      "input": {
        "simultaneousRequests": 10
      },
      "expected": {
        "counterEquals": 10,
        "noRaceConditions": true
      }
    },
    {
      "name": "Rate limit headers present",
      "input": {
        "requests": 1
      },
      "expected": {
        "hasXRateLimitLimit": true,
        "hasXRateLimitRemaining": true,
        "hasXRateLimitReset": true
      }
    }
  ],
  "hints": [
    "Use Redis sorted sets (ZSET) for sliding window implementation",
    "Store timestamps as scores in the sorted set",
    "Remove entries older than window using ZREMRANGEBYSCORE",
    "Use MULTI/EXEC transactions or Lua scripts for atomic operations",
    "Set TTL to 2x window duration for automatic cleanup",
    "Calculate reset time as: current timestamp + window duration",
    "For jitter prevention, add small random delay to retry-after",
    "Test with concurrent requests to verify accuracy",
    "Handle Redis connection failures gracefully with fallback"
  ]
}
