{
  "id": "lab-4-retry-logic",
  "title": "Advanced Retry Logic with Circuit Breaker",
  "description": "Implement production-grade retry logic with exponential backoff, circuit breaker pattern, and adaptive retry strategies for resilient AI applications",
  "difficulty": "advanced",
  "estimatedMinutes": 240,
  "language": "typescript",
  "starterCode": "// Advanced retry logic with exponential backoff and circuit breaker\n\nexport interface RetryConfig {\n  maxRetries: number\n  baseDelay: number // milliseconds\n  maxDelay: number // milliseconds\n  jitter: boolean\n  timeout: number // milliseconds\n}\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number\n  successThreshold: number\n  timeout: number // milliseconds before trying half-open\n}\n\nexport type CircuitState = 'CLOSED' | 'OPEN' | 'HALF_OPEN'\n\n// Error classification\nexport function isRetryableError(error: any): boolean {\n  // TODO: Classify errors as retryable or not\n  // Retryable: 503, 429, 502, 504, network errors, timeouts\n  // Non-retryable: 400, 401, 403, 404, validation errors\n  return false\n}\n\n// Calculate exponential backoff delay with jitter\nexport function calculateBackoff(\n  attempt: number,\n  config: RetryConfig\n): number {\n  // TODO: Implement exponential backoff\n  // Formula: min(baseDelay * 2^attempt, maxDelay)\n  // Add jitter if enabled: randomize delay by ±25%\n  return 0\n}\n\n// Circuit Breaker class\nexport class CircuitBreaker {\n  private state: CircuitState = 'CLOSED'\n  private failureCount = 0\n  private successCount = 0\n  private lastFailureTime?: number\n  \n  constructor(private config: CircuitBreakerConfig) {}\n  \n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    // TODO: Implement circuit breaker logic\n    throw new Error('Not implemented')\n  }\n  \n  getState(): CircuitState {\n    return this.state\n  }\n}\n\n// Retry with exponential backoff\nexport async function retryWithBackoff<T>(\n  operation: () => Promise<T>,\n  config: RetryConfig\n): Promise<T> {\n  // TODO: Implement retry logic with exponential backoff\n  throw new Error('Not implemented')\n}",
  "instructions": "Implement production-grade retry logic with exponential backoff and circuit breaker pattern.\n\n**Objectives:**\n- Implement exponential backoff with configurable max retries\n- Add jitter to prevent thundering herd problem\n- Build circuit breaker with states: Closed, Open, Half-Open\n- Classify errors into retryable vs non-retryable categories\n- Implement adaptive retry logic based on error patterns\n- Track retry metrics and performance\n\n**Implementation Steps:**\n\n1. **Implement isRetryableError function:**\n   - Check error.response.status if present:\n     - Retryable: 429 (rate limit), 503 (service unavailable), 502/504 (gateway errors)\n     - Non-retryable: 400 (bad request), 401 (unauthorized), 403 (forbidden), 404 (not found)\n   - Check error.code for network errors:\n     - Retryable: ECONNRESET, ETIMEDOUT, ENOTFOUND, ECONNREFUSED\n     - Non-retryable: validation errors, programming errors\n   - Return boolean indicating if error should be retried\n\n2. **Implement calculateBackoff function:**\n   - Calculate exponential delay: baseDelay * (2 ^ attempt)\n   - Cap at maxDelay: Math.min(exponentialDelay, maxDelay)\n   - If jitter enabled, randomize delay by ±25%:\n     - actualDelay = delay * (0.75 + Math.random() * 0.5)\n   - Return final delay in milliseconds\n\n3. **Implement CircuitBreaker class:**\n   \n   **execute method:**\n   - Check current state:\n     - CLOSED: Execute operation normally\n     - OPEN: Check if timeout elapsed\n       - If yes, transition to HALF_OPEN and allow request\n       - If no, reject immediately with circuit open error\n     - HALF_OPEN: Allow limited requests to test recovery\n   - Try executing operation\n   - On success:\n     - Increment success count\n     - If in HALF_OPEN and success count >= successThreshold, transition to CLOSED\n     - Reset failure count\n   - On failure:\n     - Increment failure count\n     - If failure count >= failureThreshold, transition to OPEN\n     - Record last failure time\n     - Rethrow error\n   \n   **getState method:**\n   - If state is OPEN and timeout elapsed, transition to HALF_OPEN\n   - Return current state\n\n4. **Implement retryWithBackoff function:**\n   - Loop from attempt 0 to maxRetries:\n     - Try executing operation\n     - If success, return result\n     - If error:\n       - Check if error is retryable with isRetryableError\n       - If not retryable, throw immediately\n       - If retryable and not last attempt:\n         - Calculate backoff delay\n         - Wait for delay (use setTimeout with Promise)\n         - Continue to next attempt\n   - If all retries exhausted, throw last error\n\n5. **Implement AdaptiveRetryManager class:**\n   - Track rolling success rate (last 100 requests)\n   - Adjust maxRetries based on success rate:\n     - >80% success: 3 retries\n     - 50-80% success: 2 retries\n     - <50% success: 1 retry\n   - recordAttempt method: update success rate\n   - getRetryConfig method: return adjusted config\n\n6. **Create resilient API client:**\n   - Combine circuit breaker and retry logic\n   - Wrap OpenAI API calls with both patterns\n   - Track metrics (attempts, success rate, latency)\n   - Implement graceful degradation when circuit is open\n\n**Circuit Breaker States:**\n- CLOSED: Normal operation, requests pass through\n- OPEN: Too many failures, reject requests immediately\n- HALF_OPEN: Testing recovery, allow limited requests\n\n**Retry Strategy:**\n- Attempt 0: 0s (immediate)\n- Attempt 1: ~1s (1000ms ± 25%)\n- Attempt 2: ~2s (2000ms ± 25%)\n- Attempt 3: ~4s (4000ms ± 25%)\n\n**Testing:**\n- Test transient error recovers with retry\n- Test exponential backoff timing is correct\n- Test non-retryable error fails immediately\n- Test circuit breaker opens after threshold failures\n- Test jitter prevents thundering herd\n- Test adaptive retry reduces attempts on high failure rate",
  "testCases": [
    {
      "name": "Transient error recovers with retry",
      "input": {
        "firstCallStatus": 503,
        "secondCallStatus": 200
      },
      "expected": {
        "retryAttempted": true,
        "eventualSuccess": true,
        "delayApproximately": 1000
      }
    },
    {
      "name": "Exponential backoff timing correct",
      "input": {
        "failureCount": 3,
        "status": 503
      },
      "expected": {
        "delay1": "~1000ms",
        "delay2": "~2000ms",
        "delay3": "~4000ms",
        "hasJitter": true
      }
    },
    {
      "name": "Non-retryable error fails immediately",
      "input": {
        "status": 401
      },
      "expected": {
        "retryAttempts": 0,
        "immediateFailure": true
      }
    },
    {
      "name": "Circuit breaker opens after failures",
      "input": {
        "failureThreshold": 5,
        "consecutiveFailures": 5
      },
      "expected": {
        "circuitState": "OPEN",
        "blocksNextRequest": true,
        "noAPICall": true
      }
    },
    {
      "name": "Circuit breaker transitions to half-open",
      "input": {
        "circuitOpen": true,
        "waitTimeoutMs": 60000
      },
      "expected": {
        "stateAfterTimeout": "HALF_OPEN",
        "allowsTestRequest": true
      }
    },
    {
      "name": "Jitter prevents thundering herd",
      "input": {
        "simultaneousFailures": 10
      },
      "expected": {
        "retryTimesSpreadOut": true,
        "notSynchronized": true,
        "variancePercent": 25
      }
    },
    {
      "name": "Adaptive retry reduces attempts",
      "input": {
        "successRate": 0.4
      },
      "expected": {
        "maxRetries": 1,
        "reducedFromDefault": true
      }
    },
    {
      "name": "Error classification correct",
      "input": {
        "errors": [429, 503, 502, 504, "ETIMEDOUT", 400, 401, 404]
      },
      "expected": {
        "retryable": [429, 503, 502, 504, "ETIMEDOUT"],
        "nonRetryable": [400, 401, 404]
      }
    }
  ],
  "hints": [
    "Exponential backoff formula: delay = min(baseDelay * 2^attempt, maxDelay)",
    "Add jitter: actualDelay = delay * (0.75 + Math.random() * 0.5)",
    "Circuit breaker states: CLOSED → OPEN → HALF_OPEN → CLOSED",
    "Retryable errors: 429, 503, 502, 504, ECONNRESET, ETIMEDOUT",
    "Non-retryable errors: 400, 401, 403, 404, validation errors",
    "Use setTimeout wrapped in Promise for delays",
    "Track timestamps to verify exponential backoff timing",
    "Open circuit after N failures, stay open for timeout, then try HALF_OPEN",
    "In HALF_OPEN, close circuit after M successes",
    "Adaptive retry: adjust maxRetries based on rolling success rate",
    "For production, consider using existing libraries like retry or p-retry",
    "Handle timeouts with Promise.race and AbortController"
  ]
}
