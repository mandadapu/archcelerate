---
title: "Development Workflow Integration"
description: "Integrate AI code review into your development workflow"
estimatedMinutes: 30
---

# Development Workflow Integration

## Integration Points

AI code review can integrate at multiple points in the development workflow:

```
Code â†’ Commit â†’ PR â†’ Review â†’ Merge â†’ Deploy
  â†“       â†“      â†“      â†“       â†“       â†“
 IDE    Pre-   GitHub  Auto   Quality Deploy
Plugin commit  Action  Review  Gates   Check
```

## IDE Integration

### VS Code Extension

```typescript
// extension.ts
import * as vscode from 'vscode'

export function activate(context: vscode.ExtensionContext) {
  // Register command
  const disposable = vscode.commands.registerCommand(
    'aicelerate.reviewFile',
    async () => {
      const editor = vscode.window.activeTextEditor
      if (!editor) return

      const code = editor.document.getText()
      const language = editor.document.languageId

      // Show progress
      await vscode.window.withProgress(
        {
          location: vscode.ProgressLocation.Notification,
          title: 'Reviewing code...'
        },
        async () => {
          const issues = await reviewCode(code, language)
          showIssues(editor, issues)
        }
      )
    }
  )

  context.subscriptions.push(disposable)
}

function showIssues(
  editor: vscode.TextEditor,
  issues: Issue[]
) {
  const diagnostics = issues.map(issue => {
    const range = new vscode.Range(
      issue.line - 1,
      0,
      issue.line - 1,
      999
    )

    const diagnostic = new vscode.Diagnostic(
      range,
      issue.message,
      severityMap[issue.severity]
    )

    diagnostic.source = 'AI Code Review'
    diagnostic.code = issue.code

    return diagnostic
  })

  vscode.languages.setDiagnostics(
    editor.document.uri,
    diagnostics
  )
}
```

### IntelliJ Plugin

```kotlin
// CodeReviewAction.kt
class AICodeReviewAction : AnAction() {
    override fun actionPerformed(e: AnActionEvent) {
        val project = e.project ?: return
        val editor = e.getData(CommonDataKeys.EDITOR) ?: return

        val document = editor.document
        val code = document.text

        ProgressManager.getInstance().run(
            object : Task.Backgroundable(project, "AI Code Review") {
                override fun run(indicator: ProgressIndicator) {
                    val issues = reviewCode(code)

                    ApplicationManager.getApplication().invokeLater {
                        showIssues(editor, issues)
                    }
                }
            }
        )
    }
}
```

## Git Hooks

### Pre-commit Hook

```bash
#!/bin/bash
# .git/hooks/pre-commit

echo "Running AI code review..."

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\\.(ts|js|py)$')

if [ -z "$STAGED_FILES" ]; then
  exit 0
fi

# Review each file
for FILE in $STAGED_FILES; do
  echo "Reviewing $FILE..."

  # Call review API
  ISSUES=$(npx tsx scripts/review-file.ts "$FILE")

  # Check for blockers
  if echo "$ISSUES" | grep -q "BLOCKER"; then
    echo "âŒ Blocking issues found in $FILE"
    echo "$ISSUES"
    exit 1
  fi
done

echo "âœ… Code review passed"
exit 0
```

### Review Script

```typescript
// scripts/review-file.ts
import { readFile } from 'fs/promises'
import { reviewCode } from '../src/lib/review'

async function main() {
  const filePath = process.argv[2]
  const code = await readFile(filePath, 'utf-8')

  const issues = await reviewCode(code)

  // Filter blockers
  const blockers = issues.filter(i => i.severity === 'BLOCKER')

  if (blockers.length > 0) {
    console.log('Blocking issues:')
    blockers.forEach(issue => {
      console.log(`  Line ${issue.line}: ${issue.message}`)
    })
    process.exit(1)
  }

  console.log('âœ… No blocking issues')
  process.exit(0)
}

main()
```

## GitHub Actions

### PR Review Workflow

```yaml
# .github/workflows/ai-review.yml
name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Run AI Code Review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          npm run review:pr -- ${{ github.event.pull_request.number }}

      - name: Post Review Comment
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs')
            const review = fs.readFileSync('review-results.json', 'utf8')
            const data = JSON.parse(review)

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: data.summary
            })
```

### Review Script for CI

```typescript
// scripts/review-pr.ts
import { Octokit } from '@octokit/rest'
import { reviewPullRequest } from '../src/lib/reviewer'

async function main() {
  const prNumber = parseInt(process.argv[2])
  const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN })

  // Get PR details
  const { data: pr } = await octokit.pulls.get({
    owner: 'your-org',
    repo: 'your-repo',
    pull_number: prNumber
  })

  // Review PR
  const review = await reviewPullRequest(pr)

  // Write results
  await writeFile('review-results.json', JSON.stringify(review, null, 2))

  // Fail if blockers
  if (review.hasBlockers) {
    console.error('Blocking issues found')
    process.exit(1)
  }
}

main()
```

## GitLab Integration

### GitLab CI Configuration

```yaml
# .gitlab-ci.yml
ai-review:
  stage: test
  image: node:18
  script:
    - npm ci
    - npm run review:mr -- $CI_MERGE_REQUEST_IID
  only:
    - merge_requests
  artifacts:
    reports:
      codequality: review-report.json
```

### MR Review Script

```typescript
import { Gitlab } from '@gitbeaker/node'

const gitlab = new Gitlab({
  token: process.env.GITLAB_TOKEN
})

async function reviewMR(projectId: string, mrIid: number) {
  // Get MR changes
  const changes = await gitlab.MergeRequests.changes(projectId, mrIid)

  // Review each file
  const reviews = await Promise.all(
    changes.changes.map(change => reviewDiff(change.diff))
  )

  // Post discussions
  for (const review of reviews.flat()) {
    if (review.severity === 'BLOCKER') {
      await gitlab.MergeRequestDiscussions.create(
        projectId,
        mrIid,
        review.message,
        {
          position: {
            position_type: 'text',
            new_path: review.file,
            new_line: review.line
          }
        }
      )
    }
  }
}
```

## Slack Integration

### Review Notifications

```typescript
import { WebClient } from '@slack/web-api'

const slack = new WebClient(process.env.SLACK_TOKEN)

async function notifyReview(review: Review) {
  const blockers = review.issues.filter(i => i.severity === 'BLOCKER')

  if (blockers.length > 0) {
    await slack.chat.postMessage({
      channel: '#code-reviews',
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `ðŸš¨ *Blocking Issues Found in PR #${review.prNumber}*`
          }
        },
        {
          type: 'section',
          fields: blockers.map(issue => ({
            type: 'mrkdwn',
            text: `*${issue.file}:${issue.line}*\n${issue.message}`
          }))
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: { type: 'plain_text', text: 'View PR' },
              url: review.prUrl
            }
          ]
        }
      ]
    })
  }
}
```

## Custom Dashboard

### Review Dashboard

```typescript
// app/reviews/page.tsx
export default async function ReviewsDashboard() {
  const reviews = await prisma.codeReview.findMany({
    orderBy: { createdAt: 'desc' },
    take: 50,
    include: {
      pullRequest: true,
      issues: true
    }
  })

  return (
    <div>
      <h1>Code Reviews</h1>

      {reviews.map(review => (
        <ReviewCard key={review.id}>
          <h3>PR #{review.pullRequest.number}: {review.pullRequest.title}</h3>

          <Stats>
            <Stat label="Blockers" value={review.blockerCount} severity="error" />
            <Stat label="Major" value={review.majorCount} severity="warning" />
            <Stat label="Minor" value={review.minorCount} severity="info" />
          </Stats>

          <IssueList issues={review.issues} />

          <Actions>
            <Button href={review.pullRequest.url}>View PR</Button>
            <Button onClick={() => dismissReview(review.id)}>Dismiss</Button>
          </Actions>
        </ReviewCard>
      ))}
    </div>
  )
}
```

## Configuration Management

### Centralized Config

```typescript
// .aicelerate/review-config.ts
export default {
  // Severity thresholds
  thresholds: {
    blocker: {
      security: true,
      correctness: true,
      dataLoss: true
    },
    major: {
      performance: true,
      maintainability: false,
      testCoverage: false
    }
  },

  // Files to ignore
  ignore: [
    '**/node_modules/**',
    '**/*.test.ts',
    '**/dist/**'
  ],

  // Review rules
  rules: {
    'no-hardcoded-secrets': 'error',
    'missing-error-handling': 'warning',
    'complex-function': 'info',
    'missing-tests': 'warning'
  },

  // Integration settings
  integrations: {
    github: {
      enabled: true,
      autoComment: true,
      blockOnErrors: true
    },
    slack: {
      enabled: true,
      channel: '#code-reviews',
      notifyOnBlockers: true
    }
  }
}
```

## Metrics & Analytics

### Track Review Metrics

```typescript
interface ReviewMetrics {
  totalReviews: number
  averageIssuesPerReview: number
  mostCommonIssues: IssueType[]
  falsePositiveRate: number
  timeToReview: number
  developerSatisfaction: number
}

async function collectMetrics(): Promise<ReviewMetrics> {
  const reviews = await prisma.codeReview.findMany({
    where: {
      createdAt: {
        gte: thirtyDaysAgo()
      }
    },
    include: {
      issues: true,
      feedback: true
    }
  })

  return {
    totalReviews: reviews.length,
    averageIssuesPerReview: calculateAverage(reviews),
    mostCommonIssues: findCommonIssues(reviews),
    falsePositiveRate: calculateFalsePositives(reviews),
    timeToReview: calculateAverageTime(reviews),
    developerSatisfaction: calculateSatisfaction(reviews)
  }
}
```

## Best Practices

1. **Start small**: Begin with pre-commit hooks, expand to CI/CD
2. **Configure thresholds**: Don't block on every issue
3. **Developer feedback**: Collect and act on false positive reports
4. **Performance**: Cache results, batch API calls
5. **Fallbacks**: Don't fail builds if review service is down
6. **Documentation**: Explain why reviews are failing
7. **Metrics**: Track and optimize review effectiveness

## Exercise

Build an integration:
1. Create a GitHub Action for PR reviews
2. Add pre-commit hook for local review
3. Set up Slack notifications
4. Build a review dashboard
5. Track metrics and false positives

## Resources

- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [GitLab CI/CD](https://docs.gitlab.com/ee/ci/)
- [Git Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)
- [VS Code Extension API](https://code.visualstudio.com/api)
