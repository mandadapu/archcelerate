---
title: 'Lab: Support Ticket Router'
description: 'Build an enterprise support system comparing JSON Mode vs Structured Outputs'
estimatedTime: 120
difficulty: 'intermediate'
---

# Lab: Support Ticket Router

## Overview

In this lab, you'll build an enterprise support ticket routing system that extracts structured data from messy customer emails. You'll compare three approaches:
1. **JSON Mode** (prompt-based)
2. **Structured Outputs** (strict schema enforcement)
3. **Function Calling** (orchestrated workflows)

**Key Learning**: You'll see firsthand why JSON Mode hallucinates flexible values like `"very high"` for priority, while Structured Outputs enforces the integer `10` that your database expects.

---

## The Business Problem

Your company receives hundreds of customer support emails daily:

```
From: angry.customer@example.com
Subject: URGENT!!!

Your app keeps crashing when I try to export data! This is the
third time this week. I'm losing hours of work and my team is
furious. We're on the Enterprise plan and this is unacceptable.

Product: Dashboard Pro (SKU-12345)
Account: enterprise-tier

I need this fixed IMMEDIATELY or we're switching to a competitor.
```

**Your task**: Extract structured data to route tickets efficiently:
- **Sentiment**: How frustrated is the customer?
- **Category**: What type of issue? (technical, billing, feature_request)
- **Priority**: How urgent? (1-10 scale)
- **Product ID**: Which product? (must match SKU-##### format)
- **Customer Tier**: Which plan? (free, pro, enterprise)

---

## Phase 1: JSON Mode (The Fragile Approach)

### Exercise 1: Extract with JSON Mode

**Goal**: Use prompt engineering to get JSON output.

```typescript
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })

async function extractTicketJsonMode(emailContent: string): Promise<any> {
  const response = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20240620',
    max_tokens: 500,
    messages: [{
      role: 'user',
      content: `Extract support ticket data from this email and return ONLY valid JSON.

Schema:
{
  "sentiment": string ("frustrated" | "neutral" | "happy"),
  "category": string ("technical" | "billing" | "feature_request"),
  "priority": number (1-10, where 10 is most urgent),
  "product_id": string (format: SKU-#####),
  "customer_tier": string ("free" | "pro" | "enterprise"),
  "urgency_keywords": array of strings (words that indicate urgency)
}

Email:
${emailContent}

Return only the JSON, no explanation.`
    }]
  })

  const content = response.content[0]
  if (content.type !== 'text') {
    throw new Error('Unexpected response type')
  }

  return JSON.parse(content.text)
}

// Test
const email = `From: angry.customer@example.com
Subject: URGENT!!!

Your app keeps crashing when I try to export data! This is the
third time this week. I'm losing hours of work and my team is
furious. We're on the Enterprise plan and this is unacceptable.

Product: Dashboard Pro (SKU-12345)
Account: enterprise-tier

I need this fixed IMMEDIATELY or we're switching to a competitor.`

const result = await extractTicketJsonMode(email)
console.log(result)
```

**Run this code** and observe the output:

```json
{
  "sentiment": "very frustrated",
  "category": "technical issue",
  "priority": "critical",
  "product_id": "SKU-12345",
  "customer_tier": "enterprise",
  "urgency_keywords": ["URGENT", "IMMEDIATELY", "furious", "third time", "unacceptable"]
}
```

### ‚ùå Problems with JSON Mode Output

**Try inserting this into your database**:

```typescript
interface TicketRecord {
  sentiment: 'frustrated' | 'neutral' | 'happy'
  category: 'technical' | 'billing' | 'feature_request'
  priority: number // 1-10
  product_id: string
  customer_tier: 'free' | 'pro' | 'enterprise'
}

// ‚ùå This will fail!
const ticket: TicketRecord = result
// Error: Type "very frustrated" is not assignable to type '"frustrated" | "neutral" | "happy"'
// Error: Type "critical" is not assignable to type 'number'
```

**What went wrong?**

1. **sentiment**: LLM returned `"very frustrated"` instead of `"frustrated"`
2. **category**: LLM returned `"technical issue"` instead of `"technical"`
3. **priority**: LLM returned `"critical"` (string) instead of `10` (number)

**The fundamental problem**: JSON Mode only guarantees **syntactically valid JSON**. It does NOT guarantee the JSON matches your schema.

---

## Phase 2: Structured Outputs (The Reliable Approach)

### Exercise 2: Enforce Schema with Zod + Structured Outputs

**Goal**: Use Zod to define and enforce the exact schema.

```typescript
import { z } from 'zod'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })

// 1. Define strict schema with Zod
const TicketSchema = z.object({
  sentiment: z.enum(['frustrated', 'neutral', 'happy']),
  category: z.enum(['technical', 'billing', 'feature_request']),
  priority: z.number().int().min(1).max(10),
  product_id: z.string().regex(/^SKU-[0-9]{5}$/),
  customer_tier: z.enum(['free', 'pro', 'enterprise']),
  urgency_keywords: z.array(z.string()).max(10)
})

type Ticket = z.infer<typeof TicketSchema>

// 2. Extract with structured output
async function extractTicketStructured(emailContent: string): Promise<Ticket> {
  const response = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20240620',
    max_tokens: 500,
    system: `You are a support ticket classifier. Extract data matching this schema:

sentiment: MUST be exactly "frustrated", "neutral", or "happy" (lowercase, no variations)
category: MUST be exactly "technical", "billing", or "feature_request"
priority: MUST be an integer from 1-10 (10 = most urgent)
product_id: MUST match format SKU-##### (5 digits)
customer_tier: MUST be exactly "free", "pro", or "enterprise"
urgency_keywords: List of words indicating urgency (max 10)

Rules:
- sentiment: Use "frustrated" for angry/upset customers, even if very frustrated
- priority: 1-3=low, 4-6=medium, 7-9=high, 10=critical (based on keywords like URGENT, IMMEDIATELY)
- If unclear, default to priority=5, sentiment="neutral"`,
    messages: [{
      role: 'user',
      content: `Extract ticket data from:\n\n${emailContent}`
    }]
  })

  const content = response.content[0]
  if (content.type !== 'text') {
    throw new Error('Unexpected response type')
  }

  // 3. Parse and validate
  const parsed = JSON.parse(content.text)
  const validated = TicketSchema.parse(parsed) // Throws if invalid

  return validated
}

// Test
const email = `From: angry.customer@example.com
Subject: URGENT!!!

Your app keeps crashing when I try to export data! This is the
third time this week. I'm losing hours of work and my team is
furious. We're on the Enterprise plan and this is unacceptable.

Product: Dashboard Pro (SKU-12345)
Account: enterprise-tier

I need this fixed IMMEDIATELY or we're switching to a competitor.`

const ticket = await extractTicketStructured(email)
console.log(ticket)

// ‚úÖ This works! Type-safe and validated
const dbRecord: Ticket = ticket
await db.tickets.create({ data: ticket })
```

**Output**:

```json
{
  "sentiment": "frustrated",
  "category": "technical",
  "priority": 10,
  "product_id": "SKU-12345",
  "customer_tier": "enterprise",
  "urgency_keywords": ["URGENT", "IMMEDIATELY", "furious", "third time", "unacceptable", "crashing"]
}
```

### ‚úÖ Why This Works

1. **Exact enum values**: `"frustrated"` not `"very frustrated"`
2. **Correct types**: `priority: 10` (number) not `"critical"` (string)
3. **Format validation**: `product_id` matches `SKU-#####` regex
4. **Type safety**: TypeScript knows exact shape
5. **Database ready**: Can insert directly without transformation

### Exercise 3: Compare the Approaches

**Create a comparison test**:

```typescript
const testEmails = [
  {
    name: 'Critical Bug',
    email: `URGENT: App crashing on export! Enterprise customer, SKU-12345`
  },
  {
    name: 'Billing Question',
    email: `Hi, question about invoice #INV-789. Product: SKU-99999. Thanks!`
  },
  {
    name: 'Feature Request',
    email: `Would be nice if we could filter by date. Pro plan, SKU-11111`
  }
]

async function compareApproaches() {
  console.log('=== JSON Mode vs Structured Outputs Comparison ===\n')

  for (const test of testEmails) {
    console.log(`\nTest: ${test.name}`)
    console.log('‚îÄ'.repeat(60))

    // JSON Mode
    try {
      const jsonResult = await extractTicketJsonMode(test.email)
      console.log('JSON Mode Output:', jsonResult)
      console.log('  ‚ùå priority type:', typeof jsonResult.priority)
      console.log('  ‚ùå sentiment:', jsonResult.sentiment)
    } catch (error) {
      console.log('JSON Mode FAILED:', error.message)
    }

    // Structured Outputs
    try {
      const structuredResult = await extractTicketStructured(test.email)
      console.log('\nStructured Output:', structuredResult)
      console.log('  ‚úÖ priority type:', typeof structuredResult.priority)
      console.log('  ‚úÖ sentiment:', structuredResult.sentiment)
      console.log('  ‚úÖ Database ready: YES')
    } catch (error) {
      console.log('Structured FAILED:', error.message)
    }

    console.log()
  }
}

await compareApproaches()
```

**Expected Output**:

```
=== JSON Mode vs Structured Outputs Comparison ===

Test: Critical Bug
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
JSON Mode Output: {
  sentiment: 'extremely frustrated',
  priority: 'URGENT',
  category: 'critical technical issue'
}
  ‚ùå priority type: string
  ‚ùå sentiment: extremely frustrated

Structured Output: {
  sentiment: 'frustrated',
  priority: 10,
  category: 'technical',
  product_id: 'SKU-12345',
  customer_tier: 'enterprise'
}
  ‚úÖ priority type: number
  ‚úÖ sentiment: frustrated
  ‚úÖ Database ready: YES
```

### Exercise 3.5: Add Subscription Lookup Tool (Prevent Hallucinations)

**Goal**: Query real Zendesk API instead of letting LLM hallucinate subscription data.

**Business Problem**: When tickets ask "Can I add more users?" or "What features do I have?", the LLM might invent subscription tier information. This creates legal risk (promising features customers don't have).

**Solution**: Give LLM a tool to query the real subscription database.

```typescript
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })

// Define subscription lookup tool
const querySubscriptionTool: Anthropic.Tool = {
  name: 'query_zendesk_subscription',
  description: `Query Zendesk API to get customer's current subscription tier and features.

Use this ONLY when the ticket is about:
- Billing questions ("What features do I have?")
- Account limits ("Can I add more users?")
- Upgrade eligibility ("Can I upgrade to Pro?")

DO NOT call this for general technical questions or bugs.`,
  input_schema: {
    type: 'object',
    properties: {
      user_email: {
        type: 'string',
        format: 'email',
        description: 'Customer email address from the ticket'
      },
      query_reason: {
        type: 'string',
        enum: ['check_features', 'check_limits', 'check_upgrade_eligibility'],
        description: 'Why you need subscription data'
      }
    },
    required: ['user_email', 'query_reason']
  }
}

// Define classification tool (same as before)
const classifyTicketTool: Anthropic.Tool = {
  name: 'classify_support_ticket',
  description: 'Classify and route the support ticket based on analysis',
  input_schema: {
    type: 'object',
    properties: {
      sentiment: { type: 'string', enum: ['frustrated', 'neutral', 'happy'] },
      category: { type: 'string', enum: ['technical', 'billing', 'feature_request'] },
      priority: { type: 'integer', minimum: 1, maximum: 10 },
      product_id: { type: 'string', pattern: '^SKU-[0-9]{5}$' },
      customer_tier: { type: 'string', enum: ['free', 'pro', 'enterprise'] },
      requires_human: { type: 'boolean' },
      suggested_fix: { type: 'string' }
    },
    required: ['sentiment', 'category', 'priority', 'requires_human']
  }
}

// Implement subscription lookup
async function queryZendeskSubscription(
  userEmail: string,
  queryReason: string
): Promise<{
  tier: string
  features: string[]
  userLimit: number
  currentUsers: number
  renewalDate: string
}> {
  console.log(`[ZENDESK API] Looking up ${userEmail} (reason: ${queryReason})`)

  // In production: Real Zendesk API call
  // const response = await fetch(`https://api.zendesk.com/v2/users/search?query=${userEmail}`, {
  //   headers: { 'Authorization': `Bearer ${process.env.ZENDESK_API_KEY}` }
  // })

  // Simulated response
  const subscriptionData = {
    tier: 'professional',
    features: ['team_collaboration', 'advanced_analytics', 'priority_support', 'api_access'],
    userLimit: 10,
    currentUsers: 7,
    renewalDate: '2026-03-15'
  }

  console.log(`‚úÖ Subscription data retrieved:`, subscriptionData)
  return subscriptionData
}

// Multi-turn orchestration
async function routeTicketWithSubscriptionLookup(
  emailContent: string,
  userEmail: string
): Promise<{
  classification: any
  subscriptionData?: any
  instantResolution: boolean
  cost: number
}> {
  let cost = 0.015 // Base LLM cost
  let subscriptionData: any = null
  let instantResolution = false

  // Turn 1: LLM analyzes ticket and decides if subscription lookup needed
  const response = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20240620',
    max_tokens: 2048,
    tools: [querySubscriptionTool, classifyTicketTool],
    tool_choice: { type: 'auto' }, // Let LLM decide if tools needed
    messages: [{
      role: 'user',
      content: `Analyze this support ticket:

From: ${userEmail}
Content: "${emailContent}"

If this is about billing, features, or account limits, use query_zendesk_subscription to get accurate data.
Otherwise, classify directly using classify_support_ticket.

IMPORTANT: Do NOT invent subscription information. If you need it, call the tool.`
    }]
  })

  console.log('\nü§ñ LLM Decision:')

  const toolUses = response.content.filter(block => block.type === 'tool_use')

  if (toolUses.length > 0) {
    const toolResults: Anthropic.ToolResultBlockParam[] = []

    for (const toolUse of toolUses) {
      if (toolUse.type === 'tool_use') {
        console.log(`   Tool: ${toolUse.name}`)
        console.log(`   Args:`, toolUse.input)

        if (toolUse.name === 'query_zendesk_subscription') {
          // LLM decided it needs subscription data
          cost += 0.02 // Zendesk API cost
          subscriptionData = await queryZendeskSubscription(
            toolUse.input.user_email,
            toolUse.input.query_reason
          )

          toolResults.push({
            type: 'tool_result',
            tool_use_id: toolUse.id,
            content: JSON.stringify(subscriptionData)
          })

          // Check if this can be instantly resolved
          if (toolUse.input.query_reason === 'check_limits') {
            instantResolution = true
          }
        } else if (toolUse.name === 'classify_support_ticket') {
          // LLM classified without needing subscription data
          const classification = toolUse.input
          return {
            classification,
            subscriptionData: null,
            instantResolution: false,
            cost
          }
        }
      }
    }

    // Turn 2: LLM generates final response with subscription data
    const finalResponse = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20240620',
      max_tokens: 2048,
      tools: [querySubscriptionTool, classifyTicketTool],
      tool_choice: { type: 'tool', name: 'classify_support_ticket' }, // Force classification
      messages: [
        { role: 'user', content: `Analyze this support ticket:\n\nFrom: ${userEmail}\nContent: "${emailContent}"\n\nIf this is about billing, features, or account limits, use query_zendesk_subscription to get accurate data.\nOtherwise, classify directly using classify_support_ticket.\n\nIMPORTANT: Do NOT invent subscription information. If you need it, call the tool.` },
        { role: 'assistant', content: response.content },
        { role: 'user', content: toolResults }
      ]
    })

    cost += 0.015 // Second LLM call

    // Extract classification
    const classificationTool = finalResponse.content.find(
      block => block.type === 'tool_use' && block.name === 'classify_support_ticket'
    )

    if (classificationTool && classificationTool.type === 'tool_use') {
      const classification = classificationTool.input

      return {
        classification,
        subscriptionData,
        instantResolution,
        cost
      }
    }
  }

  throw new Error('LLM failed to classify ticket')
}

// Test 1: Billing question (needs subscription data)
const billingEmail = `Hi, I want to add 5 more users to my account but I'm not sure if my current plan supports it. Can you help?`

console.log('=== Test 1: Billing Question ===')
const result1 = await routeTicketWithSubscriptionLookup(billingEmail, 'customer@example.com')

console.log('\nüìä Result:')
console.log('Classification:', result1.classification)
console.log('Subscription:', result1.subscriptionData)
console.log('Instant Resolution:', result1.instantResolution ? 'YES' : 'NO')
console.log('Cost:', `$${result1.cost.toFixed(3)}`)

// Expected output:
// Classification: { category: 'billing', priority: 5, requires_human: false }
// Subscription: { tier: 'professional', userLimit: 10, currentUsers: 7 }
// Instant Resolution: YES
// Cost: $0.045

// Test 2: Technical question (no subscription lookup needed)
const technicalEmail = `The export feature is crashing when I try to download CSV files. This is urgent!`

console.log('\n\n=== Test 2: Technical Question ===')
const result2 = await routeTicketWithSubscriptionLookup(technicalEmail, 'customer@example.com')

console.log('\nüìä Result:')
console.log('Classification:', result2.classification)
console.log('Subscription:', result2.subscriptionData) // Should be null
console.log('Cost:', `$${result2.cost.toFixed(3)}`)

// Expected output:
// Classification: { category: 'technical', priority: 9, requires_human: true }
// Subscription: null
// Cost: $0.015 (no API call needed)
```

**Key Observations**:

1. **LLM Decides When to Call API**: For technical questions, it skips the expensive Zendesk API call
2. **Zero Hallucinations**: Subscription data comes from real API, not LLM imagination
3. **Instant Resolution**: 40%+ of billing questions can be answered without human ("You have 3 users left")
4. **Cost Optimization**: Only pays $0.02 API fee when genuinely needed

**Comparison**:

| Approach | Hallucination Risk | Cost | Instant Resolution |
|----------|-------------------|------|-------------------|
| ‚ùå LLM invents data | High (50% wrong) | $0.015 | 10% |
| ‚úÖ Tool-based lookup | None (API-verified) | $0.015-$0.045 | 41% |

**Cost Breakdown (500 tickets/day)**:
- **Technical tickets** (250/day, 50%): $0.015 each = $3.75/day (no API call)
- **Billing tickets** (250/day, 50%): $0.045 each = $11.25/day (includes API)
- **Total**: $15/day = $450/month

**Without tool calling**: $225K/year in manual support labor
**With tool calling**: $5,400/year in API costs = **98% cost reduction**

---

## Phase 3: Function Calling (The Orchestration)

### Exercise 4: Add Action Tools

**Goal**: Let the LLM orchestrate actions based on ticket priority.

```typescript
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })

// Define tools
const tools: Anthropic.Tool[] = [
  {
    name: 'lookup_inventory',
    description: 'Check if a product is in stock. Use this when the ticket mentions a product issue.',
    input_schema: {
      type: 'object',
      properties: {
        product_id: {
          type: 'string',
          pattern: '^SKU-[0-9]{5}$',
          description: 'Product SKU (format: SKU-12345)'
        }
      },
      required: ['product_id']
    }
  },
  {
    name: 'check_recent_outages',
    description: 'Check if there have been recent service outages affecting this product. Use for technical issues.',
    input_schema: {
      type: 'object',
      properties: {
        product_id: {
          type: 'string',
          pattern: '^SKU-[0-9]{5}$'
        },
        hours_back: {
          type: 'integer',
          minimum: 1,
          maximum: 168,
          description: 'How many hours to look back (max 7 days)'
        }
      },
      required: ['product_id', 'hours_back']
    }
  },
  {
    name: 'escalate_to_engineering',
    description: 'Escalate ticket to engineering team. ONLY use for priority >= 8 with technical category.',
    input_schema: {
      type: 'object',
      properties: {
        ticket_id: { type: 'string' },
        priority: {
          type: 'integer',
          minimum: 8,
          maximum: 10
        },
        reason: { type: 'string' }
      },
      required: ['ticket_id', 'priority', 'reason']
    }
  },
  {
    name: 'send_automated_response',
    description: 'Send templated response to customer. Use for low priority or common issues.',
    input_schema: {
      type: 'object',
      properties: {
        customer_email: { type: 'string', format: 'email' },
        template: {
          type: 'string',
          enum: ['acknowledge', 'known_issue', 'workaround_provided', 'escalated']
        },
        estimated_resolution_hours: { type: 'integer', minimum: 1 }
      },
      required: ['customer_email', 'template']
    }
  }
]

// Implement tool functions
async function lookupInventory(product_id: string): Promise<any> {
  // Simulated inventory check
  return {
    product_id,
    in_stock: true,
    quantity: 150,
    status: 'active'
  }
}

async function checkRecentOutages(product_id: string, hours_back: number): Promise<any> {
  // Simulated outage check
  return {
    product_id,
    outages: [
      {
        start: '2024-02-03T14:30:00Z',
        end: '2024-02-03T15:15:00Z',
        affected_features: ['export', 'data_sync'],
        severity: 'high'
      }
    ],
    total_downtime_minutes: 45
  }
}

async function escalateToEngineering(ticket_id: string, priority: number, reason: string): Promise<any> {
  console.log(`üö® ESCALATED to Engineering: Ticket ${ticket_id} (Priority ${priority})`)
  console.log(`   Reason: ${reason}`)
  return { escalated: true, assigned_to: 'engineering-team', eta: '2 hours' }
}

async function sendAutomatedResponse(customer_email: string, template: string, estimated_resolution_hours?: number): Promise<any> {
  console.log(`üìß Sent ${template} email to ${customer_email}`)
  if (estimated_resolution_hours) {
    console.log(`   ETA: ${estimated_resolution_hours} hours`)
  }
  return { sent: true, template }
}

// Orchestration loop
async function processTicketWithTools(emailContent: string, ticket: Ticket): Promise<void> {
  console.log('\nüéØ Processing ticket with AI orchestration...\n')

  const messages: Anthropic.MessageParam[] = [
    {
      role: 'user',
      content: `Process this support ticket and take appropriate actions:

Ticket:
  Priority: ${ticket.priority}/10
  Category: ${ticket.category}
  Sentiment: ${ticket.sentiment}
  Product: ${ticket.product_id}
  Customer: ${ticket.customer_tier}

Email:
${emailContent}

Based on priority and category, decide what actions to take:
- Priority 8-10 + technical: Check outages, escalate to engineering
- Priority 1-5: Send automated response
- Product issues: Check inventory

Take the necessary actions using available tools.`
    }
  ]

  let response = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20240620',
    max_tokens: 2000,
    tools,
    messages
  })

  // Tool execution loop
  while (response.stop_reason === 'tool_use') {
    const toolUses = response.content.filter(
      (block): block is Anthropic.ToolUseBlock => block.type === 'tool_use'
    )

    const toolResults: Anthropic.ToolResultBlockParam[] = []

    for (const toolUse of toolUses) {
      console.log(`üîß Tool: ${toolUse.name}`)
      console.log(`   Args:`, toolUse.input)

      let result: any

      try {
        switch (toolUse.name) {
          case 'lookup_inventory':
            result = await lookupInventory(toolUse.input.product_id)
            break
          case 'check_recent_outages':
            result = await checkRecentOutages(toolUse.input.product_id, toolUse.input.hours_back)
            break
          case 'escalate_to_engineering':
            result = await escalateToEngineering(toolUse.input.ticket_id, toolUse.input.priority, toolUse.input.reason)
            break
          case 'send_automated_response':
            result = await sendAutomatedResponse(toolUse.input.customer_email, toolUse.input.template, toolUse.input.estimated_resolution_hours)
            break
          default:
            throw new Error(`Unknown tool: ${toolUse.name}`)
        }

        console.log(`   ‚úÖ Result:`, result)

        toolResults.push({
          type: 'tool_result',
          tool_use_id: toolUse.id,
          content: JSON.stringify(result)
        })
      } catch (error) {
        console.log(`   ‚ùå Error:`, error.message)

        toolResults.push({
          type: 'tool_result',
          tool_use_id: toolUse.id,
          content: JSON.stringify({ error: error.message }),
          is_error: true
        })
      }
    }

    // Continue conversation
    messages.push(
      { role: 'assistant', content: response.content },
      { role: 'user', content: toolResults }
    )

    response = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20240620',
      max_tokens: 2000,
      tools,
      messages
    })
  }

  // Final response
  const textBlock = response.content.find(
    (block): block is Anthropic.TextBlock => block.type === 'text'
  )

  console.log('\nüìã Summary:', textBlock?.text)
}

// Test
const email = `From: angry.customer@example.com
Subject: URGENT!!!

Your app keeps crashing when I try to export data! This is the
third time this week. I'm losing hours of work and my team is
furious. We're on the Enterprise plan and this is unacceptable.

Product: Dashboard Pro (SKU-12345)

I need this fixed IMMEDIATELY or we're switching to a competitor.`

const ticket = await extractTicketStructured(email)
await processTicketWithTools(email, ticket)
```

**Expected Output**:

```
üéØ Processing ticket with AI orchestration...

üîß Tool: check_recent_outages
   Args: { product_id: 'SKU-12345', hours_back: 72 }
   ‚úÖ Result: {
     outages: [{ start: '2024-02-03T14:30:00Z', affected_features: ['export'] }],
     total_downtime_minutes: 45
   }

üîß Tool: escalate_to_engineering
   Args: { ticket_id: 'TKT-001', priority: 10, reason: 'Critical export bug affecting enterprise customer, recent outage detected' }
   üö® ESCALATED to Engineering: Ticket TKT-001 (Priority 10)
      Reason: Critical export bug affecting enterprise customer, recent outage detected
   ‚úÖ Result: { escalated: true, assigned_to: 'engineering-team', eta: '2 hours' }

üìß Sent escalated email to angry.customer@example.com
   ETA: 2 hours

üìã Summary: I've identified this as a critical issue (Priority 10). Recent outages
affecting the export feature were detected in the past 72 hours. I've escalated
this to our engineering team with a 2-hour ETA and notified the customer that
we're treating this as top priority.
```

---

## Phase 4: Add Validation Layer (Prevent Hallucinations)

### Exercise 5: Validate Tool Arguments with Zod

**Problem**: LLM might hallucinate tool arguments that don't exist in your database.

```typescript
// ‚ùå Bad: LLM invents user_id
{
  tool: 'escalate_to_engineering',
  args: {
    ticket_id: 'TKT-99999',  // Doesn't exist!
    priority: 10,
    reason: 'Critical issue'
  }
}
```

**Solution**: Validate all tool inputs before execution.

```typescript
import { z } from 'zod'

// Define schemas for tool inputs
const LookupInventoryArgsSchema = z.object({
  product_id: z.string().regex(/^SKU-[0-9]{5}$/)
})

const EscalateArgsSchema = z.object({
  ticket_id: z.string().regex(/^TKT-[0-9]{3,6}$/),
  priority: z.number().int().min(8).max(10),
  reason: z.string().min(10).max(500)
})

// Validated tool executor
async function executeToolSafely(
  toolName: string,
  args: unknown
): Promise<any> {
  console.log(`\nüîç Validating tool: ${toolName}`)

  try {
    switch (toolName) {
      case 'lookup_inventory': {
        const validated = LookupInventoryArgsSchema.parse(args)
        return await lookupInventory(validated.product_id)
      }

      case 'escalate_to_engineering': {
        const validated = EscalateArgsSchema.parse(args)

        // Additional business logic validation
        const ticketExists = await db.tickets.findUnique({
          where: { id: validated.ticket_id }
        })

        if (!ticketExists) {
          throw new Error(`Ticket ${validated.ticket_id} does not exist`)
        }

        return await escalateToEngineering(
          validated.ticket_id,
          validated.priority,
          validated.reason
        )
      }

      default:
        throw new Error(`Unknown tool: ${toolName}`)
    }
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.log(`‚ùå Validation failed:`, error.errors)
      return {
        error: 'Invalid arguments',
        details: error.errors.map(e => ({
          field: e.path.join('.'),
          message: e.message
        }))
      }
    }

    throw error
  }
}

// Test validation
const validArgs = {
  product_id: 'SKU-12345'
}

const invalidArgs = {
  product_id: 'INVALID-ID'  // Wrong format
}

await executeToolSafely('lookup_inventory', validArgs)   // ‚úÖ Works
await executeToolSafely('lookup_inventory', invalidArgs) // ‚ùå Returns error
```

---

## Phase 5: Production Metrics & ROI Tracking

### Exercise 6: Track Resolution Rate Metrics

**Goal**: Measure the business impact of your auto-router by tracking instant resolution rate, cost savings, and accuracy.

**Business Context**: Your stakeholders want to know: "Is this AI system actually saving money and improving customer experience?" You need concrete metrics to prove ROI.

**Key Metrics to Track**:
1. **Instant Resolution Rate**: % of tickets resolved without human handoff
2. **Cost per Ticket**: LLM + API costs vs manual labor
3. **Accuracy**: % of correct classifications (vs human gold standard)
4. **Customer Satisfaction**: Sentiment trends over time

#### Implementation

```typescript
import { z } from 'zod'

interface ResolutionMetrics {
  ticketId: string
  timestamp: Date
  category: string
  priority: number
  requiresHuman: boolean
  instantlyResolved: boolean
  processingCost: number
  processingTime: number
  toolsCalled: string[]
  accuracyScore?: number // Compare to human classification (0-1)
}

class SupportMetricsTracker {
  private metrics: ResolutionMetrics[] = []

  async trackTicket(
    ticketId: string,
    classification: any,
    subscriptionData: any | null,
    cost: number,
    processingTime: number
  ): Promise<void> {
    // Determine if instantly resolved
    const instantlyResolved = this.isInstantlyResolved(
      classification,
      subscriptionData
    )

    // Track which tools were used
    const toolsCalled: string[] = []
    if (subscriptionData) toolsCalled.push('query_zendesk_subscription')

    const metric: ResolutionMetrics = {
      ticketId,
      timestamp: new Date(),
      category: classification.category,
      priority: classification.priority,
      requiresHuman: classification.requires_human,
      instantlyResolved,
      processingCost: cost,
      processingTime,
      toolsCalled
    }

    this.metrics.push(metric)

    // Log to analytics service in production
    await this.persistMetric(metric)

    console.log(`üìä Metric tracked: ${ticketId} - Instant Resolution: ${instantlyResolved}`)
  }

  private isInstantlyResolved(
    classification: any,
    subscriptionData: any | null
  ): boolean {
    // Instant resolution criteria:
    // 1. Low priority (1-6) general questions
    // 2. Billing questions where we have subscription data
    // 3. Known issues with workarounds

    if (classification.category === 'billing' && subscriptionData) {
      return true // Can answer "Can I add users?" immediately
    }

    if (classification.priority <= 6 && !classification.requires_human) {
      return true // Low priority, doesn't need human
    }

    return false
  }

  async generateDailyReport(): Promise<{
    instantResolutionRate: number
    avgCostPerTicket: number
    avgProcessingTime: number
    costSavings: number
    categoryBreakdown: Record<string, number>
  }> {
    const today = new Date()
    today.setHours(0, 0, 0, 0)

    const todayMetrics = this.metrics.filter(
      m => m.timestamp >= today
    )

    if (todayMetrics.length === 0) {
      return {
        instantResolutionRate: 0,
        avgCostPerTicket: 0,
        avgProcessingTime: 0,
        costSavings: 0,
        categoryBreakdown: {}
      }
    }

    const instantlyResolved = todayMetrics.filter(m => m.instantlyResolved).length
    const instantResolutionRate = (instantlyResolved / todayMetrics.length) * 100

    const totalCost = todayMetrics.reduce((sum, m) => sum + m.processingCost, 0)
    const avgCostPerTicket = totalCost / todayMetrics.length

    const totalTime = todayMetrics.reduce((sum, m) => sum + m.processingTime, 0)
    const avgProcessingTime = totalTime / todayMetrics.length

    // Calculate cost savings vs manual processing
    const manualCostPerTicket = 0.50 // $0.50 per ticket (5 mins at $6/hour)
    const costSavings = (manualCostPerTicket * todayMetrics.length) - totalCost

    // Category breakdown
    const categoryBreakdown: Record<string, number> = {}
    for (const metric of todayMetrics) {
      categoryBreakdown[metric.category] = (categoryBreakdown[metric.category] || 0) + 1
    }

    return {
      instantResolutionRate,
      avgCostPerTicket,
      avgProcessingTime,
      costSavings,
      categoryBreakdown
    }
  }

  private async persistMetric(metric: ResolutionMetrics): Promise<void> {
    // In production: Send to analytics platform
    // await analytics.track('support_ticket_processed', metric)

    // Or store in database for historical analysis
    // await db.supportMetrics.create({ data: metric })
  }

  printReport(report: Awaited<ReturnType<typeof this.generateDailyReport>>): void {
    console.log('\n' + '='.repeat(60))
    console.log('üìä DAILY SUPPORT METRICS REPORT')
    console.log('='.repeat(60))
    console.log(`\nüéØ Instant Resolution Rate: ${report.instantResolutionRate.toFixed(1)}%`)
    console.log(`   Target: 40% | Status: ${report.instantResolutionRate >= 40 ? '‚úÖ PASS' : '‚ùå MISS'}`)

    console.log(`\nüí∞ Cost Metrics:`)
    console.log(`   Avg Cost per Ticket: $${report.avgCostPerTicket.toFixed(3)}`)
    console.log(`   Daily Savings: $${report.costSavings.toFixed(2)}`)
    console.log(`   Annual Savings: $${(report.costSavings * 365).toFixed(0)}`)

    console.log(`\n‚ö° Performance:`)
    console.log(`   Avg Processing Time: ${report.avgProcessingTime.toFixed(0)}ms`)

    console.log(`\nüìÅ Category Breakdown:`)
    for (const [category, count] of Object.entries(report.categoryBreakdown)) {
      console.log(`   ${category}: ${count}`)
    }

    console.log('\n' + '='.repeat(60))
  }
}

// Usage Example
const metricsTracker = new SupportMetricsTracker()

async function processAndTrackTicket(emailContent: string, userEmail: string): Promise<void> {
  const startTime = Date.now()

  // Process ticket
  const result = await routeTicketWithSubscriptionLookup(emailContent, userEmail)

  const processingTime = Date.now() - startTime

  // Generate ticket ID
  const ticketId = `TKT-${Date.now().toString().slice(-6)}`

  // Track metrics
  await metricsTracker.trackTicket(
    ticketId,
    result.classification,
    result.subscriptionData,
    result.cost,
    processingTime
  )
}

// Test with sample tickets
const testTickets = [
  {
    email: 'Can I add 5 more users to my Professional plan?',
    user: 'customer1@example.com'
  },
  {
    email: 'URGENT: Export feature is completely broken!',
    user: 'customer2@example.com'
  },
  {
    email: 'How do I reset my password?',
    user: 'customer3@example.com'
  },
  {
    email: 'What features are included in the Enterprise tier?',
    user: 'customer4@example.com'
  },
  {
    email: 'I need a refund for last month',
    user: 'customer5@example.com'
  }
]

console.log('üöÄ Processing test tickets...\n')

for (const ticket of testTickets) {
  await processAndTrackTicket(ticket.email, ticket.user)
  await new Promise(resolve => setTimeout(resolve, 100)) // Small delay between requests
}

// Generate daily report
const report = await metricsTracker.generateDailyReport()
metricsTracker.printReport(report)
```

#### Expected Output

```
üöÄ Processing test tickets...

üìä Metric tracked: TKT-123456 - Instant Resolution: true
üìä Metric tracked: TKT-123457 - Instant Resolution: false
üìä Metric tracked: TKT-123458 - Instant Resolution: true
üìä Metric tracked: TKT-123459 - Instant Resolution: true
üìä Metric tracked: TKT-123460 - Instant Resolution: false

============================================================
üìä DAILY SUPPORT METRICS REPORT
============================================================

üéØ Instant Resolution Rate: 60.0%
   Target: 40% | Status: ‚úÖ PASS

üí∞ Cost Metrics:
   Avg Cost per Ticket: $0.027
   Daily Savings: $2.37
   Annual Savings: $864

‚ö° Performance:
   Avg Processing Time: 1847ms

üìÅ Category Breakdown:
   billing: 3
   technical: 2

============================================================
```

#### Business Impact Analysis

**Comparison: Manual vs AI-Powered**

| Metric | Manual Support | AI Auto-Router | Improvement |
|--------|----------------|----------------|-------------|
| **Instant Resolution** | 10% | 60% | +500% |
| **Cost per Ticket** | $0.50 | $0.027 | -94.6% |
| **Processing Time** | 8 minutes | 1.8 seconds | -99.6% |
| **Daily Cost (500 tickets)** | $250 | $13.50 | -94.6% |
| **Annual Cost** | $91,250 | $4,928 | **$86,322 savings** |

#### Key Insights from Metrics

1. **Instant Resolution Rate (60%) exceeds target (40%)**
   - Billing questions with subscription lookup: 100% instant resolution
   - Low-priority questions: 80% instant resolution
   - High-priority technical: 0% instant resolution (correctly escalated)

2. **Cost Optimization**
   - 40% of tickets don't need Zendesk API call (pure classification)
   - Average cost: $0.027/ticket ($0.015-$0.045 range)
   - ROI: $86K/year in labor savings

3. **Accuracy Validation**
   - Compare AI classification to human gold standard
   - Target: &gt;95% agreement on priority/category
   - If accuracy < 90%, retrain prompts or add few-shot examples

#### Production Monitoring Dashboard

```typescript
// Weekly trend analysis
async function analyzeWeeklyTrends(): Promise<void> {
  const weeklyData = await db.supportMetrics.groupBy({
    by: ['category'],
    where: {
      timestamp: {
        gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      }
    },
    _avg: {
      processingCost: true,
      processingTime: true
    },
    _count: {
      instantlyResolved: true
    }
  })

  console.log('üìà 7-Day Trend Analysis:')
  console.log('  Instant Resolution Rate:', weeklyData._count.instantlyResolved)
  console.log('  Avg Cost:', weeklyData._avg.processingCost)
  console.log('  Avg Time:', weeklyData._avg.processingTime)
}

// Alert on degradation
async function checkMetricsHealth(): Promise<void> {
  const last24h = await metricsTracker.generateDailyReport()

  if (last24h.instantResolutionRate < 35) {
    console.warn('üö® ALERT: Instant resolution rate below threshold (35%)')
    console.warn('   Action: Review recent tickets for classification errors')
  }

  if (last24h.avgCostPerTicket > 0.05) {
    console.warn('üö® ALERT: Cost per ticket exceeds budget ($0.05)')
    console.warn('   Action: LLM may be over-using expensive API calls')
  }
}
```

#### Deliverable: Metrics Dashboard

Create a simple web dashboard showing:

```typescript
// app/api/support-metrics/route.ts
export async function GET() {
  const metrics = await metricsTracker.generateDailyReport()

  return Response.json({
    instantResolutionRate: metrics.instantResolutionRate,
    costSavings: metrics.costSavings * 365, // Annual projection
    avgProcessingTime: metrics.avgProcessingTime,
    categoryBreakdown: metrics.categoryBreakdown,
    healthStatus: metrics.instantResolutionRate >= 40 ? 'healthy' : 'degraded'
  })
}
```

**Target Metrics for Production**:
- ‚úÖ Instant Resolution Rate: &gt;40%
- ‚úÖ Cost per Ticket: <$0.05
- ‚úÖ Processing Time: &lt;3 seconds
- ‚úÖ Classification Accuracy: &gt;95% (vs human gold standard)

---

## Deliverables

### Part 1: Comparison Report

Create a markdown file comparing the three approaches:

```markdown
# Support Ticket Router: Approach Comparison

## Test Results

| Approach | Priority Type | Valid Enums | Database Ready | Reliability |
|----------|--------------|-------------|----------------|-------------|
| JSON Mode | ‚ùå String | ‚ùå Flexible values | ‚ùå No | ~70% |
| Structured Outputs | ‚úÖ Number | ‚úÖ Exact values | ‚úÖ Yes | ~98% |
| Function Calling | ‚úÖ Number | ‚úÖ Exact values | ‚úÖ Yes | ~98% |

## Key Findings

1. **JSON Mode Hallucinations**: Returned "very high" instead of 10, "extremely frustrated" instead of "frustrated"
2. **Structured Outputs Enforcement**: Forced exact schema match, type-safe
3. **Function Calling Orchestration**: Correctly escalated priority 10 tickets, checked outages first
4. **Validation Layer**: Caught hallucinated ticket IDs before database errors

## Recommendation

Use Structured Outputs for all production data extraction. Add Zod validation for function calling arguments.
```

### Part 2: Production Implementation

Implement a complete support ticket processor:

```typescript
async function processCustomerEmail(
  emailContent: string,
  customerEmail: string
): Promise<ProcessingResult> {
  // 1. Extract structured data
  const ticket = await extractTicketStructured(emailContent)

  // 2. Save to database
  const dbTicket = await db.tickets.create({
    data: {
      ...ticket,
      customerEmail,
      status: 'open',
      createdAt: new Date()
    }
  })

  // 3. Orchestrate actions
  await processTicketWithTools(emailContent, ticket)

  // 4. Return summary
  return {
    ticketId: dbTicket.id,
    priority: ticket.priority,
    estimatedResolution: calculateETA(ticket.priority),
    actionsToken: ['checked_outages', 'escalated_to_engineering']
  }
}
```

---

## Bonus Challenges

1. **Multi-Language Support**: Handle emails in Spanish, French, German
2. **Attachment Processing**: Extract data from attached screenshots
3. **Thread Handling**: Process email threads, not just single emails
4. **Sentiment Trends**: Track sentiment changes across multiple tickets from same customer
5. **Smart Routing**: Use embeddings to find similar resolved tickets

---

## Key Takeaways

1. **JSON Mode** only guarantees syntactically valid JSON, not schema adherence
2. **Structured Outputs** with Zod enforces exact types and formats
3. **Function Calling** enables multi-step orchestration
4. **Always validate** tool arguments to prevent hallucinated data
5. **Type safety** catches errors at compile time, not runtime

**Production Rule**: Never use JSON Mode for mission-critical data extraction. Always use Structured Outputs with validation.

---

## Lab Rubric: Support Ticket Router

### Total Points: 100

Your submission will be evaluated on four key criteria that reflect real-world production requirements.

---

### 1. Schema Design & Extraction (30 points)

**Target**: How well did you define the "Contract" between the user and the system?

**Criteria**:

**Pydantic/Zod Usage (10 points)**
- [ ] **10pts**: Schemas clearly defined with appropriate data types (enums for categories, integers for priority, regex patterns for IDs)
- [ ] **7pts**: Schemas defined but missing constraints (e.g., no min/max on priority, no regex on product_id)
- [ ] **4pts**: Basic types defined (string, number) but no enums or validation
- [ ] **0pts**: No schema definition, relying on prompt engineering only

**Extraction Accuracy (10 points)**
- [ ] **10pts**: Consistently extracts correct priority, category, product_id from noisy emails (&gt;90% accuracy on test set)
- [ ] **7pts**: Mostly accurate but occasional mistakes on edge cases
- [ ] **4pts**: Works for clean emails, fails on ambiguous cases
- [ ] **0pts**: Frequent extraction errors or wrong types

**Constraint Usage (10 points)**
- [ ] **10pts**: Uses Structured Outputs (strict mode) or constrained decoding to enforce schema 100%
- [ ] **7pts**: Uses JSON Mode with explicit instructions
- [ ] **4pts**: Relies on prompt engineering without schema enforcement
- [ ] **0pts**: No constraints, accepts any JSON structure

**Common Issues**:
- ‚ùå Using `priority: string` instead of `priority: number`
- ‚ùå Allowing free-form sentiment like "extremely frustrated" instead of enum
- ‚ùå No validation on product_id format (allows "Product 123" instead of "SKU-12345")

**Gold Standard**:
```typescript
const TicketSchema = z.object({
  sentiment: z.enum(['frustrated', 'neutral', 'happy']),
  category: z.enum(['technical', 'billing', 'feature_request']),
  priority: z.number().int().min(1).max(10),
  product_id: z.string().regex(/^SKU-[0-9]{5}$/),
  customer_tier: z.enum(['free', 'pro', 'enterprise'])
})
```

---

### 2. Tool Logic & Reliability (30 points)

**Target**: Assessing the reliability of the Function Calling implementation.

**Criteria**:

**Tool Descriptions (10 points)**
- [ ] **10pts**: Function and parameter descriptions are clear, specific, include when to use AND when NOT to use
- [ ] **7pts**: Descriptions present but vague ("process ticket" vs "escalate to engineering for priority >= 8")
- [ ] **4pts**: Minimal descriptions, LLM must guess when to use
- [ ] **0pts**: No descriptions or incorrect function definitions

**Input Validation (10 points)**
- [ ] **10pts**: Validates LLM's tool arguments with Zod/Pydantic BEFORE execution, includes business logic checks (e.g., ticket exists in DB)
- [ ] **7pts**: Basic type validation but no business logic checks
- [ ] **4pts**: Trusts LLM output without validation
- [ ] **0pts**: No validation, directly executes with LLM-provided args

**Handling No-Tool Scenarios (10 points)**
- [ ] **10pts**: Gracefully handles emails that don't require tools (thank you notes, general questions), doesn't force tool calls
- [ ] **7pts**: Handles simple cases but sometimes calls tools unnecessarily
- [ ] **4pts**: Assumes every email needs a tool call
- [ ] **0pts**: Crashes or errors when no tool is needed

**Common Issues**:
- ‚ùå Vague tool description: `"process_refund"` ‚Üí What if user not eligible?
- ‚ùå No validation: LLM invents `ticket_id: "TKT-99999"` that doesn't exist
- ‚ùå Force tool use: Sets `tool_choice: "required"` for all messages

**Gold Standard**:
```typescript
{
  name: 'escalate_to_engineering',
  description: 'Escalate ticket to engineering team. ONLY use for priority >= 8 with technical category. Do NOT use for billing or feature requests.',
  input_schema: {
    properties: {
      priority: { type: 'integer', minimum: 8, maximum: 10 }
    }
  }
}

// Validate before execution
const validated = EscalateArgsSchema.parse(args)
const ticketExists = await db.tickets.findUnique({ where: { id: validated.ticket_id } })
if (!ticketExists) throw new Error('Ticket not found')
```

---

### 3. Error Handling & Edge Cases (25 points)

**Target**: Architectural resilience.

**Criteria**:

**Truncated JSON (8 points)**
- [ ] **8pts**: Handles token limit errors, uses fallback parser (partial-json-parser), calculates appropriate max_tokens
- [ ] **5pts**: Detects truncation but only logs error
- [ ] **2pts**: Crashes on truncated JSON
- [ ] **0pts**: No handling for max_tokens issues

**Hallucination Recovery (9 points)**
- [ ] **9pts**: Catches invalid LLM arguments, provides helpful error message back to LLM for retry with corrected data
- [ ] **6pts**: Catches errors but doesn't feed back to LLM for correction
- [ ] **3pts**: Logs error but continues with bad data
- [ ] **0pts**: No hallucination detection

**Retry Logic (8 points)**
- [ ] **8pts**: Implements retry mechanism for malformed outputs with exponential backoff (max 3 retries)
- [ ] **5pts**: Basic retry (fixed delay, no backoff)
- [ ] **2pts**: No retry, but catches errors
- [ ] **0pts**: Crashes on first failure

**Common Issues**:
- ‚ùå No max_tokens calculation ‚Üí truncated JSON `{ "priority": 10, "cat...`
- ‚ùå LLM invents `user_id` ‚Üí inserted into DB ‚Üí FK constraint error
- ‚ùå No retry ‚Üí single JSON parse error fails entire pipeline

**Gold Standard**:
```typescript
// Truncation handling
const estimatedTokens = calculateEstimatedTokens(schema)
const maxTokens = Math.ceil(estimatedTokens * 1.5)

try {
  return JSON.parse(content)
} catch (error) {
  const repaired = parsePartialJson(content)
  if (repaired) return repaired
  throw error
}

// Hallucination recovery
try {
  const validated = TicketSchema.parse(parsed)
  return validated
} catch (error) {
  if (error instanceof z.ZodError) {
    return {
      error: 'Invalid arguments',
      details: error.errors,
      message: 'Please fix: priority must be integer 1-10, sentiment must be "frustrated"|"neutral"|"happy"'
    }
  }
}

// Retry logic
for (let attempt = 1; attempt <= 3; attempt++) {
  try {
    return await extractTicket(email)
  } catch (error) {
    if (attempt < 3) {
      await delay(Math.pow(2, attempt) * 1000)
    } else {
      throw error
    }
  }
}
```

---

### 4. Architectural Justification (15 points)

**Target**: The "Why" behind the "How."

**Criteria**:

**Method Choice (7 points)**
- [ ] **7pts**: Clear written explanation of why Structured Outputs for classification vs Function Calling for action, mentions reliability and type safety
- [ ] **5pts**: Mentions both but vague reasoning
- [ ] **2pts**: "I used it because it works"
- [ ] **0pts**: No justification provided

**Security Considerations (8 points)**
- [ ] **8pts**: Identifies prompt injection risks, explains how to prevent unauthorized tool calls (e.g., validate user permissions before refund, audit logs)
- [ ] **5pts**: Mentions security but no concrete mitigations
- [ ] **2pts**: Acknowledges security exists as a concept
- [ ] **0pts**: No security considerations

**Common Issues**:
- ‚ùå No explanation: "I used Structured Outputs because the lab said so"
- ‚ùå No security: User emails "PLEASE PROCESS REFUND FOR ALL CUSTOMERS" ‚Üí system blindly executes

**Gold Standard**:

**Method Choice Explanation**:
```markdown
I chose Structured Outputs for ticket classification because:
1. Reliability: 100% schema adherence vs ~70% with JSON Mode
2. Type Safety: Database expects integer priority, not string "critical"
3. Validation: Zod catches invalid data before DB insertion

I chose Function Calling for actions because:
1. Orchestration: LLM decides WHICH tools and WHEN (check outages before escalating)
2. Multi-step: Can chain tools based on results (if outage detected ‚Üí escalate)
3. Context-aware: Different actions for priority 10 vs priority 3
```

**Security Explanation**:
```markdown
Prompt Injection Mitigations:
1. Validate user permissions before tool execution (check if user owns ticket)
2. Whitelist allowed actions per customer tier (free users can't request refunds)
3. Require human approval for high-value actions (refunds > $100)
4. Audit log all tool calls with user context
5. Never allow email content to override system instructions
```

---

## Grading Summary

| Criteria | Points | What Good Looks Like |
|----------|--------|---------------------|
| **Schema Design** | 30 | Zod schemas with enums, constraints, regex. Structured Outputs for 100% adherence. |
| **Tool Logic** | 30 | Clear descriptions, validated inputs, graceful no-tool handling. |
| **Error Handling** | 25 | Handles truncation, hallucinations, retries. Fails gracefully. |
| **Justification** | 15 | Explains method choice, identifies security risks, provides mitigations. |
| **TOTAL** | 100 | |

---

## Submission Checklist

Before submitting your lab:

- [ ] All TypeScript code compiles without errors
- [ ] Schemas defined with Zod including enums, min/max, regex
- [ ] Tool functions validate inputs before execution
- [ ] Test cases for JSON Mode vs Structured Outputs comparison
- [ ] Error handling for truncated JSON and hallucinated arguments
- [ ] Retry logic with exponential backoff
- [ ] Written justification (500-800 words) explaining method choices and security
- [ ] Test with provided email examples + 3 edge cases you create
- [ ] README with setup instructions and example output

---

## Common Mistakes to Avoid

1. **Using JSON Mode for production** ‚Üí Switch to Structured Outputs
2. **No schema validation** ‚Üí Add Zod schemas with constraints
3. **Trusting LLM tool arguments** ‚Üí Validate before execution
4. **Vague tool descriptions** ‚Üí Be specific about when to use AND when NOT to use
5. **No error handling** ‚Üí Add try/catch, retries, partial JSON parsing
6. **Ignoring security** ‚Üí Validate permissions, audit logs, prevent injection
7. **No comparison** ‚Üí Must compare JSON Mode vs Structured Outputs with evidence

---

## Resources

- [Zod Documentation](https://zod.dev/)
- [Anthropic: Structured Outputs](https://docs.anthropic.com/en/docs/build-with-claude/structured-outputs)
- [Anthropic: Tool Use Best Practices](https://docs.anthropic.com/en/docs/build-with-claude/tool-use)
- Week 4 Concept Guides: structured-output.mdx, function-calling.mdx, schema-design.mdx
