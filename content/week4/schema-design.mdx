---
title: 'Schema Design & API Contracts'
description: 'Design robust tool specifications that LLMs can reliably invoke'
estimatedTime: 45
difficulty: 'intermediate'
objectives:
  - Design API contracts between LLMs and enterprise systems
  - Structure complex tool parameters and nested schemas
  - Build maintainable tool catalogs
  - Version and evolve tool specifications safely
---

# Schema Design & API Contracts

## The Architect's Mindset

> "Treat your LLM like a new developer joining your team. If they can't understand the API documentation, they'll make mistakes."

**The paradigm shift**: You're not just building an AI feature. You're designing an **API contract** between natural language (LLM) and structured systems (your enterprise software).

---

## API Contracts: LLM as a Client

### Traditional API Design

```typescript
// Your API (called by humans/code)
POST /api/orders
{
  "product_id": "SKU-12345",
  "quantity": 2,
  "priority": "express"
}

// Documentation
- product_id: string (required) - Product SKU
- quantity: integer (required) - Number of units
- priority: enum (required) - "standard" | "express" | "overnight"
```

### LLM-Ready API Design

**Same endpoint, but the "client" is an LLM that:**
- Might misinterpret vague descriptions
- Will hallucinate values if you don't provide enums
- Needs explicit examples for complex formats
- Requires context about WHEN to call this

```typescript
{
  name: 'create_order',
  description: 'Create a new product order for shipment. Use this when the user wants to buy, purchase, or order a product. Do NOT use for price quotes (use get_quote instead).',
  input_schema: {
    type: 'object',
    properties: {
      product_id: {
        type: 'string',
        description: 'Product SKU or ID (format: SKU-XXXXX where X is a digit). Example: "SKU-12345"',
        pattern: '^SKU-[0-9]{5}$'
      },
      quantity: {
        type: 'integer',
        description: 'Number of units to order',
        minimum: 1,
        maximum: 1000
      },
      priority: {
        type: 'string',
        enum: ['standard', 'express', 'overnight'],
        description: 'Shipping speed. standard=5-7 days ($10), express=2-3 days ($25), overnight=next day ($50). Default to standard unless user explicitly requests faster shipping.'
      },
      billing_address: {
        type: 'object',
        description: 'Billing address for the order',
        properties: {
          street: { type: 'string' },
          city: { type: 'string' },
          state: {
            type: 'string',
            pattern: '^[A-Z]{2}$',
            description: 'Two-letter US state code (e.g., "CA", "NY")'
          },
          zip: {
            type: 'string',
            pattern: '^[0-9]{5}$',
            description: '5-digit US ZIP code'
          }
        },
        required: ['street', 'city', 'state', 'zip']
      }
    },
    required: ['product_id', 'quantity', 'priority', 'billing_address']
  }
}
```

**Key differences**:
1. **When to use**: "Use this when..." vs just "Creates an order"
2. **When NOT to use**: "Do NOT use for..." prevents confusion
3. **Enums everywhere**: Prevents hallucination
4. **Regex patterns**: Forces correct formats
5. **Examples in descriptions**: Shows the LLM what success looks like
6. **Context in enums**: Explains implications ($10 vs $50 shipping)

---

## Parameter Design Patterns

### Pattern 1: Enums for Categorical Data

**❌ Bad: Free-form string**
```json
{
  "status": {
    "type": "string",
    "description": "Order status"
  }
}
```

LLM will invent: "in progress", "being processed", "underway", "working on it", etc.

**✅ Good: Explicit enum**
```json
{
  "status": {
    "type": "string",
    "enum": ["pending", "processing", "shipped", "delivered", "cancelled"],
    "description": "Current order status. Use 'pending' for new orders, 'processing' when preparing shipment, 'shipped' when in transit, 'delivered' when completed, 'cancelled' if order was cancelled."
  }
}
```

### Pattern 2: Bounded Numbers

**❌ Bad: Unbounded**
```json
{
  "discount_percent": {
    "type": "number",
    "description": "Discount percentage"
  }
}
```

LLM might return: 150, -10, 999

**✅ Good: Bounded with context**
```json
{
  "discount_percent": {
    "type": "number",
    "minimum": 0,
    "maximum": 50,
    "description": "Discount percentage to apply (0-50). 10 = 10% off. Maximum allowed discount is 50% per company policy."
  }
}
```

### Pattern 3: Regex Patterns for Formats

**❌ Bad: Any string**
```json
{
  "phone": {
    "type": "string",
    "description": "Phone number"
  }
}
```

LLM returns: "555-1234", "(555) 123-4567", "+1-555-123-4567", "5551234567"

**✅ Good: Enforced format**
```json
{
  "phone": {
    "type": "string",
    "pattern": "^\\+[1-9]\\d{1,14}$",
    "description": "Phone number in E.164 format (e.g., +14155552671). Must include country code."
  }
}
```

### Pattern 4: Nested Objects

```json
{
  "customer": {
    "type": "object",
    "description": "Customer information for the order",
    "properties": {
      "name": {
        "type": "string",
        "minLength": 1,
        "maxLength": 100
      },
      "email": {
        "type": "string",
        "format": "email",
        "description": "Customer's email address for order confirmation"
      },
      "shipping_address": {
        "type": "object",
        "properties": {
          "street": { "type": "string" },
          "city": { "type": "string" },
          "state": { "type": "string", "pattern": "^[A-Z]{2}$" },
          "zip": { "type": "string", "pattern": "^[0-9]{5}$" },
          "country": {
            "type": "string",
            "enum": ["US", "CA", "MX"],
            "description": "Two-letter ISO country code. Currently ship to US, Canada, and Mexico only."
          }
        },
        "required": ["street", "city", "state", "zip", "country"]
      }
    },
    "required": ["name", "email", "shipping_address"]
  }
}
```

### Pattern 5: Arrays with Item Schemas

```json
{
  "order_items": {
    "type": "array",
    "description": "List of products to order",
    "minItems": 1,
    "maxItems": 20,
    "items": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "pattern": "^SKU-[0-9]{5}$"
        },
        "quantity": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100
        }
      },
      "required": ["product_id", "quantity"]
    }
  }
}
```

---

## Complex Schema Examples

### Example 1: Support Ticket Creation

```typescript
const createTicketTool: Anthropic.Tool = {
  name: 'create_support_ticket',
  description: 'Create a customer support ticket. Use this when a customer reports a problem, asks for help, or expresses frustration. Do NOT use for general questions (use search_knowledge_base instead).',
  input_schema: {
    type: 'object',
    properties: {
      customer_email: {
        type: 'string',
        format: 'email',
        description: 'Customer\'s email address for follow-up'
      },
      subject: {
        type: 'string',
        minLength: 5,
        maxLength: 200,
        description: 'Brief summary of the issue (e.g., "Cannot log in to account")'
      },
      category: {
        type: 'string',
        enum: [
          'technical_issue',
          'billing_question',
          'feature_request',
          'account_access',
          'bug_report',
          'other'
        ],
        description: 'Issue category. Use "technical_issue" for broken features, "billing_question" for payment issues, "account_access" for login problems.'
      },
      priority: {
        type: 'string',
        enum: ['low', 'medium', 'high', 'urgent'],
        description: 'Urgency level. Use "urgent" if service is completely down or customer is very angry. Use "high" for broken core features. Use "medium" for minor issues. Use "low" for questions or feature requests.'
      },
      description: {
        type: 'string',
        minLength: 10,
        maxLength: 5000,
        description: 'Detailed description of the issue including error messages, steps to reproduce, and any relevant context.'
      },
      affected_features: {
        type: 'array',
        description: 'List of features or pages affected by this issue',
        items: {
          type: 'string',
          enum: ['login', 'dashboard', 'reports', 'api', 'mobile_app', 'billing', 'settings']
        }
      },
      customer_sentiment: {
        type: 'string',
        enum: ['satisfied', 'neutral', 'frustrated', 'angry'],
        description: 'Customer\'s emotional state based on their message tone'
      },
      metadata: {
        type: 'object',
        description: 'Additional context about the issue',
        properties: {
          browser: { type: 'string', description: 'Browser name and version if relevant' },
          os: { type: 'string', description: 'Operating system if relevant' },
          account_plan: {
            type: 'string',
            enum: ['free', 'pro', 'enterprise'],
            description: 'Customer\'s subscription tier'
          }
        }
      }
    },
    required: ['customer_email', 'subject', 'category', 'priority', 'description']
  }
}
```

### Example 2: Financial Transaction

```typescript
const transferFundsTool: Anthropic.Tool = {
  name: 'transfer_funds',
  description: 'Transfer money between accounts. CRITICAL: Only use when user explicitly requests a transfer with amount and accounts specified. Always confirm details before calling.',
  input_schema: {
    type: 'object',
    properties: {
      from_account: {
        type: 'string',
        pattern: '^[0-9]{10}$',
        description: '10-digit account number to transfer FROM'
      },
      to_account: {
        type: 'string',
        pattern: '^[0-9]{10}$',
        description: '10-digit account number to transfer TO'
      },
      amount: {
        type: 'number',
        minimum: 0.01,
        maximum: 100000,
        multipleOf: 0.01,
        description: 'Amount to transfer in USD. Maximum $100,000 per transaction.'
      },
      currency: {
        type: 'string',
        enum: ['USD', 'EUR', 'GBP', 'JPY'],
        default: 'USD',
        description: 'Currency code. Defaults to USD if not specified.'
      },
      memo: {
        type: 'string',
        maxLength: 200,
        description: 'Optional memo or description for the transfer'
      },
      schedule: {
        type: 'object',
        description: 'Optional: Schedule for future transfer. If not provided, transfer happens immediately.',
        properties: {
          date: {
            type: 'string',
            format: 'date',
            description: 'Date to execute transfer (YYYY-MM-DD). Must be today or future date.'
          },
          time: {
            type: 'string',
            pattern: '^([01][0-9]|2[0-3]):[0-5][0-9]$',
            description: 'Time to execute transfer in 24h format (HH:MM). Example: "14:30"'
          }
        },
        required: ['date']
      }
    },
    required: ['from_account', 'to_account', 'amount', 'currency']
  }
}
```

### Example 3: Entity Linking & Resolution

**The Problem**: Users say "John" but your database needs `user_id: 12345`.

**Naive approach** (prone to hallucination):
```typescript
// ❌ LLM guesses the user_id
{
  name: 'assign_task',
  input_schema: {
    properties: {
      user_id: { type: 'string', description: 'User ID' },
      task: { type: 'string' }
    }
  }
}

// User: "Assign this to John"
// LLM might hallucinate: user_id: "user_123" (doesn't exist!)
```

**Architect pattern** (two-step resolution):
```typescript
// Step 1: Search/lookup tool
{
  name: 'search_users',
  description: 'Search for users by name, email, or ID. Use this BEFORE calling any tool that requires a user_id. Returns matching users with their IDs.',
  input_schema: {
    type: 'object',
    properties: {
      query: {
        type: 'string',
        description: 'Name, email, or partial ID to search for'
      },
      limit: {
        type: 'integer',
        minimum: 1,
        maximum: 10,
        default: 5,
        description: 'Maximum number of results to return'
      }
    },
    required: ['query']
  }
}

// Step 2: Action tool (requires resolved ID)
{
  name: 'assign_task',
  description: 'Assign a task to a user. IMPORTANT: user_id must be obtained from search_users first. Do NOT guess user IDs.',
  input_schema: {
    type: 'object',
    properties: {
      user_id: {
        type: 'string',
        pattern: '^user_[0-9]+$',
        description: 'User ID from search_users result (format: user_12345)'
      },
      task_title: { type: 'string', minLength: 5, maxLength: 200 },
      task_description: { type: 'string' },
      priority: { type: 'string', enum: ['low', 'medium', 'high', 'urgent'] },
      due_date: {
        type: 'string',
        format: 'date',
        description: 'Due date in YYYY-MM-DD format'
      }
    },
    required: ['user_id', 'task_title', 'priority']
  }
}
```

**The Flow**:
```typescript
// User: "Assign 'Review PR' to John, high priority, due Friday"

// LLM automatically:
// 1. Calls search_users(query: "John")
//    → Returns: [{ id: "user_12345", name: "John Smith", email: "john@co.com" }]
//
// 2. Calls assign_task(
//      user_id: "user_12345",  // Resolved from Step 1!
//      task_title: "Review PR",
//      priority: "high",
//      due_date: "2024-03-15"
//    )
//
// 3. Responds: "I've assigned 'Review PR' to John Smith (high priority, due Friday)."
```

### Example 4: Relationship Extraction

**The Goal**: Extract entities AND their relationships for knowledge graph construction.

```typescript
interface EntityRelationshipSchema {
  entities: Array<{
    id: string           // Unique identifier generated by LLM
    type: string         // Entity type (person, company, product, etc.)
    name: string         // Human-readable name
    properties: Record<string, any>  // Additional attributes
  }>
  relationships: Array<{
    from_id: string      // References entity.id
    to_id: string        // References entity.id
    type: string         // Relationship type (works_for, acquired, etc.)
    properties: Record<string, any>  // Edge attributes (date, amount, etc.)
  }>
}

const extractEntitiesAndRelationshipsTool: Anthropic.Tool = {
  name: 'extract_knowledge_graph',
  description: 'Extract entities and their relationships from text to build a knowledge graph. Use this for processing news articles, documents, or any text describing entities and their connections.',
  input_schema: {
    type: 'object',
    properties: {
      entities: {
        type: 'array',
        description: 'All entities mentioned in the text',
        items: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              pattern: '^[a-z0-9_]+$',
              description: 'Unique ID (lowercase, underscores). Example: "john_smith", "acme_corp", "product_x"'
            },
            type: {
              type: 'string',
              enum: ['person', 'company', 'product', 'location', 'event', 'organization'],
              description: 'Entity category'
            },
            name: {
              type: 'string',
              description: 'Human-readable name as it appears in text'
            },
            properties: {
              type: 'object',
              description: 'Additional attributes extracted from text',
              properties: {
                title: { type: 'string', description: 'Job title if person' },
                industry: { type: 'string', description: 'Industry if company' },
                location: { type: 'string', description: 'Geographic location if mentioned' },
                founded: { type: 'string', description: 'Founding date if mentioned' }
              }
            }
          },
          required: ['id', 'type', 'name']
        }
      },
      relationships: {
        type: 'array',
        description: 'Relationships between entities',
        items: {
          type: 'object',
          properties: {
            from_id: {
              type: 'string',
              description: 'Source entity ID (must match an entity.id)'
            },
            to_id: {
              type: 'string',
              description: 'Target entity ID (must match an entity.id)'
            },
            type: {
              type: 'string',
              enum: [
                'works_for',      // person → company
                'founded',        // person → company
                'acquired',       // company → company
                'invested_in',    // person/company → company
                'partnered_with', // company ↔ company
                'located_in',     // any → location
                'manufactures',   // company → product
                'used_by'         // product → person/company
              ],
              description: 'Type of relationship'
            },
            properties: {
              type: 'object',
              description: 'Relationship attributes',
              properties: {
                date: { type: 'string', format: 'date', description: 'When relationship started' },
                amount: { type: 'number', description: 'Transaction amount if applicable' },
                role: { type: 'string', description: 'Specific role in relationship' }
              }
            }
          },
          required: ['from_id', 'to_id', 'type']
        }
      }
    },
    required: ['entities', 'relationships']
  }
}
```

**Usage Example**:

```typescript
// Input text: "Acme Corp, founded by Jane Doe in 2020, acquired Widgets Inc for $50M. Jane now serves as CEO."

// LLM extracts:
{
  entities: [
    {
      id: "jane_doe",
      type: "person",
      name: "Jane Doe",
      properties: { title: "CEO" }
    },
    {
      id: "acme_corp",
      type: "company",
      name: "Acme Corp",
      properties: { founded: "2020" }
    },
    {
      id: "widgets_inc",
      type: "company",
      name: "Widgets Inc",
      properties: {}
    }
  ],
  relationships: [
    {
      from_id: "jane_doe",
      to_id: "acme_corp",
      type: "founded",
      properties: { date: "2020-01-01", role: "Founder" }
    },
    {
      from_id: "acme_corp",
      to_id: "widgets_inc",
      type: "acquired",
      properties: { date: "2023-06-15", amount: 50000000 }
    },
    {
      from_id: "jane_doe",
      to_id: "acme_corp",
      type: "works_for",
      properties: { role: "CEO" }
    }
  ]
}

// Now you can:
// 1. Store in graph database (Neo4j, JanusGraph)
// 2. Query relationships: "Who founded Acme Corp?" → Jane Doe
// 3. Traverse graph: "What companies did Jane Doe found?" → Acme Corp
```

### Advanced: Entity Disambiguation

**The Problem**: "Apple" could mean Apple Inc. (company) or apple (fruit).

**Solution**: Context-aware entity resolution with confidence scores.

```typescript
const disambiguateEntityTool: Anthropic.Tool = {
  name: 'disambiguate_entity',
  description: 'Resolve ambiguous entity mentions to specific database entities. Use when a name could refer to multiple real-world entities.',
  input_schema: {
    type: 'object',
    properties: {
      mention: {
        type: 'string',
        description: 'The ambiguous text as it appears (e.g., "Apple", "John Smith")'
      },
      context: {
        type: 'string',
        description: 'Surrounding sentence or paragraph for disambiguation clues'
      },
      candidate_entities: {
        type: 'array',
        description: 'Possible entities this could refer to (from database search)',
        items: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            type: { type: 'string' },
            description: { type: 'string', description: 'Brief description to help disambiguation' }
          }
        }
      },
      selected_entity_id: {
        type: 'string',
        description: 'ID of the most likely entity based on context'
      },
      confidence: {
        type: 'number',
        minimum: 0,
        maximum: 1,
        description: 'Confidence in disambiguation (0-1). Use <0.7 if genuinely ambiguous.'
      },
      reasoning: {
        type: 'string',
        description: 'Brief explanation of why this entity was selected'
      }
    },
    required: ['mention', 'context', 'selected_entity_id', 'confidence', 'reasoning']
  }
}

// Example:
// Mention: "Apple released a new product"
// Context: "... Apple released a new product that revolutionized smartphones..."
// Candidates: [
//   { id: "apple_inc", name: "Apple Inc.", type: "company", description: "Tech company..." },
//   { id: "apple_fruit", name: "Apple", type: "food", description: "A fruit..." }
// ]
// → Selected: "apple_inc" (confidence: 0.95, reasoning: "Context mentions smartphones, indicates tech company")
```

### Production Pattern: Entity Resolution Pipeline

```typescript
/**
 * Multi-stage entity resolution for production systems
 */
class EntityResolutionPipeline {
  async resolveEntity(
    mention: string,
    context: string
  ): Promise<{
    entity_id: string | null
    confidence: number
    needsDisambiguation: boolean
  }> {
    // Stage 1: Exact match lookup
    const exactMatch = await this.exactLookup(mention)
    if (exactMatch && exactMatch.confidence > 0.95) {
      return { entity_id: exactMatch.id, confidence: exactMatch.confidence, needsDisambiguation: false }
    }

    // Stage 2: Fuzzy search
    const candidates = await this.fuzzySearch(mention, context)

    if (candidates.length === 0) {
      return { entity_id: null, confidence: 0, needsDisambiguation: false }
    }

    if (candidates.length === 1) {
      return { entity_id: candidates[0].id, confidence: 0.85, needsDisambiguation: false }
    }

    // Stage 3: LLM disambiguation
    const disambiguation = await this.llmDisambiguate(mention, context, candidates)

    return {
      entity_id: disambiguation.selected_entity_id,
      confidence: disambiguation.confidence,
      needsDisambiguation: disambiguation.confidence < 0.7
    }
  }

  private async exactLookup(mention: string): Promise<{ id: string; confidence: number } | null> {
    // Database exact match (name, alias, ID)
    const result = await db.entities.findFirst({
      where: {
        OR: [
          { name: { equals: mention, mode: 'insensitive' } },
          { aliases: { has: mention } },
          { id: mention }
        ]
      }
    })

    return result ? { id: result.id, confidence: 1.0 } : null
  }

  private async fuzzySearch(mention: string, context: string): Promise<Entity[]> {
    // Postgres full-text search or Elasticsearch
    return await db.entities.findMany({
      where: {
        name: { contains: mention, mode: 'insensitive' }
      },
      take: 5
    })
  }

  private async llmDisambiguate(
    mention: string,
    context: string,
    candidates: Entity[]
  ): Promise<{ selected_entity_id: string; confidence: number }> {
    // Call LLM with disambiguation tool
    const response = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20240620',
      max_tokens: 512,
      tools: [disambiguateEntityTool],
      messages: [{
        role: 'user',
        content: `Disambiguate "${mention}" in context: "${context}"\n\nCandidates: ${JSON.stringify(candidates)}`
      }]
    })

    const toolUse = response.content.find(block => block.type === 'tool_use')
    if (toolUse && toolUse.type === 'tool_use') {
      return {
        selected_entity_id: toolUse.input.selected_entity_id,
        confidence: toolUse.input.confidence
      }
    }

    // Fallback: highest ranked candidate
    return { selected_entity_id: candidates[0].id, confidence: 0.5 }
  }
}
```

**Key Insights**:
1. **Never let LLMs guess IDs** - Always provide lookup tools first
2. **Two-step pattern** - Search → Action (with resolved IDs)
3. **Confidence scores** - Flag ambiguous resolutions for human review
4. **Relationship extraction** - Capture connections, not just entities
5. **Disambiguation** - Use context to resolve ambiguous mentions

---

## Tool Catalog Organization

### Anti-pattern: Monolithic Tool

```typescript
// ❌ DON'T: One tool that does everything
{
  name: 'manage_inventory',
  description: 'Manage inventory',
  input_schema: {
    properties: {
      action: {
        type: 'string',
        enum: ['check', 'add', 'remove', 'transfer', 'audit']
      },
      // ... 20 more parameters for all possible actions
    }
  }
}
```

**Problems**:
- LLM confused about which parameters to use for which action
- Hard to maintain and evolve
- Poor error messages
- Difficult to version

### Best Practice: Specific Tools

```typescript
// ✅ DO: One tool per action
const inventoryTools: Anthropic.Tool[] = [
  {
    name: 'check_inventory',
    description: 'Check current stock level for a product at a specific warehouse. Use this when user asks "how many", "do we have", or "is X in stock".',
    input_schema: {
      type: 'object',
      properties: {
        product_id: { type: 'string', pattern: '^SKU-[0-9]{5}$' },
        warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] }
      },
      required: ['product_id', 'warehouse']
    }
  },
  {
    name: 'add_inventory',
    description: 'Record new inventory arriving at a warehouse. Use this when user says "received shipment" or "add stock". Requires manager permission.',
    input_schema: {
      type: 'object',
      properties: {
        product_id: { type: 'string', pattern: '^SKU-[0-9]{5}$' },
        warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] },
        quantity: { type: 'integer', minimum: 1, maximum: 10000 },
        po_number: { type: 'string', description: 'Purchase order number for audit trail' }
      },
      required: ['product_id', 'warehouse', 'quantity', 'po_number']
    }
  },
  {
    name: 'transfer_inventory',
    description: 'Move inventory between warehouses. Use when user says "move stock" or "transfer from X to Y".',
    input_schema: {
      type: 'object',
      properties: {
        product_id: { type: 'string', pattern: '^SKU-[0-9]{5}$' },
        from_warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] },
        to_warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] },
        quantity: { type: 'integer', minimum: 1 }
      },
      required: ['product_id', 'from_warehouse', 'to_warehouse', 'quantity']
    }
  }
]
```

**Benefits**:
- ✅ Clear purpose for each tool
- ✅ Minimal parameters (no conditional logic)
- ✅ Easy to add new tools without breaking existing ones
- ✅ Better LLM tool selection accuracy

---

## Versioning & Evolution

### Problem: Breaking Changes

```typescript
// Version 1 (production)
{
  name: 'create_order',
  input_schema: {
    properties: {
      priority: { enum: ['standard', 'express'] }
    }
  }
}

// Version 2 (breaks existing behavior!)
{
  name: 'create_order',
  input_schema: {
    properties: {
      // ❌ BREAKING: removed 'express', added 'overnight'
      priority: { enum: ['standard', 'overnight'] }
    }
  }
}
```

### Solution: Versioned Tools

```typescript
// Old version (deprecated but still works)
{
  name: 'create_order_v1',
  description: '[DEPRECATED] Use create_order_v2 instead. This version will be removed on 2024-12-31.',
  input_schema: {
    properties: {
      priority: { enum: ['standard', 'express'] }
    }
  }
}

// New version
{
  name: 'create_order_v2',
  description: 'Create a product order [v2]. Replaces create_order_v1 with additional overnight shipping option.',
  input_schema: {
    properties: {
      priority: {
        enum: ['standard', 'express', 'overnight'],
        description: 'standard=5-7 days, express=2-3 days, overnight=next day'
      }
    }
  }
}
```

### Solution: Backwards-Compatible Changes

```typescript
// ✅ Safe: Add optional field
{
  name: 'create_order',
  input_schema: {
    properties: {
      priority: { enum: ['standard', 'express'] },
      gift_message: { type: 'string', description: 'Optional gift message' } // NEW
    }
  }
}

// ✅ Safe: Add new enum value (if it has sensible default)
{
  name: 'create_order',
  input_schema: {
    properties: {
      priority: {
        enum: ['standard', 'express', 'overnight'], // Added 'overnight'
        default: 'standard'
      }
    }
  }
}
```

---

## Testing Tool Specifications

```typescript
import { z } from 'zod'
import Anthropic from '@anthropic-ai/sdk'

// 1. Define expected behavior
const testCases = [
  {
    userMessage: 'What\'s the weather in London?',
    expectedTool: 'get_weather',
    expectedArgs: { location: 'London', unit: 'celsius' }
  },
  {
    userMessage: 'Ship 5 units of SKU-12345 to New York',
    expectedTool: 'create_shipment',
    expectedArgs: {
      product_id: 'SKU-12345',
      quantity: 5,
      destination: expect.stringContaining('New York')
    }
  },
  {
    userMessage: 'How much does overnight shipping cost?',
    expectedTool: 'calculate_shipping_cost',
    expectedArgs: { service_level: 'overnight' }
  }
]

// 2. Run tests
async function testToolSelection(testCase: typeof testCases[0]) {
  const response = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20240620',
    max_tokens: 1024,
    tools: allTools,
    messages: [{
      role: 'user',
      content: testCase.userMessage
    }]
  })

  // Check if LLM selected correct tool
  const toolUse = response.content.find(
    (block): block is Anthropic.ToolUseBlock => block.type === 'tool_use'
  )

  if (!toolUse) {
    throw new Error(`Expected tool use, got: ${response.stop_reason}`)
  }

  if (toolUse.name !== testCase.expectedTool) {
    throw new Error(
      `Expected tool ${testCase.expectedTool}, got ${toolUse.name}`
    )
  }

  // Validate arguments match schema
  const tool = allTools.find(t => t.name === testCase.expectedTool)!
  // ... validate toolUse.input against tool.input_schema

  console.log(`✅ Test passed: ${testCase.userMessage}`)
}

// 3. Run all tests
for (const testCase of testCases) {
  await testToolSelection(testCase)
}
```

---

## Production Checklist

Before deploying tools to production:

- [ ] **Clear descriptions** - Explain when to use AND when NOT to use
- [ ] **Enums for categorical data** - Never use free-form strings
- [ ] **Bounded numbers** - Set min/max for all numeric parameters
- [ ] **Regex patterns** - Enforce formats (phone, email, SKU, etc.)
- [ ] **Required fields** - Mark all mandatory parameters
- [ ] **Examples** - Include example values in descriptions
- [ ] **Nested validation** - Validate all levels of nested objects
- [ ] **Array constraints** - Set minItems/maxItems
- [ ] **Error messages** - Return helpful errors from tool functions
- [ ] **Versioning strategy** - Plan for evolving tools over time
- [ ] **Test coverage** - Test tool selection with realistic inputs
- [ ] **Authorization checks** - Validate permissions before execution
- [ ] **Observability** - Log all tool invocations
- [ ] **Documentation** - Document each tool's purpose and use cases

---

## Key Takeaways

### The Contract Mindset

> "You're not building an AI feature. You're designing an API contract where the client speaks natural language."

### Three Layers of Schema Design

1. **Structural** (JSON Schema) - Type, required, min/max
2. **Semantic** (Descriptions) - When to use, what values mean
3. **Operational** (Error handling) - What to do when things fail

### Common Mistakes

| Mistake | Impact | Solution |
|---------|--------|----------|
| Vague descriptions | LLM selects wrong tool | Explain when to use AND when NOT to use |
| No enums | LLM hallucinates values | Use enums for all categorical data |
| Unbounded numbers | Invalid values (999999) | Set realistic min/max |
| Generic tool names | Confusion between similar tools | Specific names (calculate_shipping_cost vs process) |
| Missing examples | LLM guesses format | Include example values |

### Why This Matters

**Bad schemas** → LLM confusion → Wrong tool selection → Production failures

**Good schemas** → Clear intent → Correct tool selection → Reliable system

**Schema design is not a nice-to-have. It's the foundation of reliable AI systems.**

---

## Next Steps

- [Week 4 Lab](../lab/support-ticket-router) - Build a Support Ticket Router with schema-driven tools
- [Week 5: AI Agents](../../week5/) - Chain tools to build autonomous agents
- [Week 7: Observability](../../week7/) - Monitor tool usage in production

---

## Further Reading

### Standards
- [JSON Schema Specification](https://json-schema.org/)
- [OpenAPI 3.0 Parameter Objects](https://swagger.io/specification/)

### Best Practices
- [Anthropic: Tool Use Best Practices](https://docs.anthropic.com/en/docs/build-with-claude/tool-use#best-practices-for-tool-definitions)
- [OpenAI: Function Calling Guide](https://platform.openai.com/docs/guides/function-calling)
- [Designing APIs for AI Agents](https://www.anthropic.com/research/building-effective-agents)
