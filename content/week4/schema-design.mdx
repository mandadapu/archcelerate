---
title: 'Schema Design & API Contracts'
description: 'Design robust tool specifications that LLMs can reliably invoke'
estimatedTime: 45
difficulty: 'intermediate'
objectives:
  - Design API contracts between LLMs and enterprise systems
  - Structure complex tool parameters and nested schemas
  - Build maintainable tool catalogs
  - Version and evolve tool specifications safely
---

# Schema Design & API Contracts

## The Architect's Mindset

> "Treat your LLM like a new developer joining your team. If they can't understand the API documentation, they'll make mistakes."

**The paradigm shift**: You're not just building an AI feature. You're designing an **API contract** between natural language (LLM) and structured systems (your enterprise software).

---

## API Contracts: LLM as a Client

### Traditional API Design

```typescript
// Your API (called by humans/code)
POST /api/orders
{
  "product_id": "SKU-12345",
  "quantity": 2,
  "priority": "express"
}

// Documentation
- product_id: string (required) - Product SKU
- quantity: integer (required) - Number of units
- priority: enum (required) - "standard" | "express" | "overnight"
```

### LLM-Ready API Design

**Same endpoint, but the "client" is an LLM that:**
- Might misinterpret vague descriptions
- Will hallucinate values if you don't provide enums
- Needs explicit examples for complex formats
- Requires context about WHEN to call this

```typescript
{
  name: 'create_order',
  description: 'Create a new product order for shipment. Use this when the user wants to buy, purchase, or order a product. Do NOT use for price quotes (use get_quote instead).',
  input_schema: {
    type: 'object',
    properties: {
      product_id: {
        type: 'string',
        description: 'Product SKU or ID (format: SKU-XXXXX where X is a digit). Example: "SKU-12345"',
        pattern: '^SKU-[0-9]{5}$'
      },
      quantity: {
        type: 'integer',
        description: 'Number of units to order',
        minimum: 1,
        maximum: 1000
      },
      priority: {
        type: 'string',
        enum: ['standard', 'express', 'overnight'],
        description: 'Shipping speed. standard=5-7 days ($10), express=2-3 days ($25), overnight=next day ($50). Default to standard unless user explicitly requests faster shipping.'
      },
      billing_address: {
        type: 'object',
        description: 'Billing address for the order',
        properties: {
          street: { type: 'string' },
          city: { type: 'string' },
          state: {
            type: 'string',
            pattern: '^[A-Z]{2}$',
            description: 'Two-letter US state code (e.g., "CA", "NY")'
          },
          zip: {
            type: 'string',
            pattern: '^[0-9]{5}$',
            description: '5-digit US ZIP code'
          }
        },
        required: ['street', 'city', 'state', 'zip']
      }
    },
    required: ['product_id', 'quantity', 'priority', 'billing_address']
  }
}
```

**Key differences**:
1. **When to use**: "Use this when..." vs just "Creates an order"
2. **When NOT to use**: "Do NOT use for..." prevents confusion
3. **Enums everywhere**: Prevents hallucination
4. **Regex patterns**: Forces correct formats
5. **Examples in descriptions**: Shows the LLM what success looks like
6. **Context in enums**: Explains implications ($10 vs $50 shipping)

---

## Parameter Design Patterns

### Pattern 1: Enums for Categorical Data

**❌ Bad: Free-form string**
```json
{
  "status": {
    "type": "string",
    "description": "Order status"
  }
}
```

LLM will invent: "in progress", "being processed", "underway", "working on it", etc.

**✅ Good: Explicit enum**
```json
{
  "status": {
    "type": "string",
    "enum": ["pending", "processing", "shipped", "delivered", "cancelled"],
    "description": "Current order status. Use 'pending' for new orders, 'processing' when preparing shipment, 'shipped' when in transit, 'delivered' when completed, 'cancelled' if order was cancelled."
  }
}
```

### Pattern 2: Bounded Numbers

**❌ Bad: Unbounded**
```json
{
  "discount_percent": {
    "type": "number",
    "description": "Discount percentage"
  }
}
```

LLM might return: 150, -10, 999

**✅ Good: Bounded with context**
```json
{
  "discount_percent": {
    "type": "number",
    "minimum": 0,
    "maximum": 50,
    "description": "Discount percentage to apply (0-50). 10 = 10% off. Maximum allowed discount is 50% per company policy."
  }
}
```

### Pattern 3: Regex Patterns for Formats

**❌ Bad: Any string**
```json
{
  "phone": {
    "type": "string",
    "description": "Phone number"
  }
}
```

LLM returns: "555-1234", "(555) 123-4567", "+1-555-123-4567", "5551234567"

**✅ Good: Enforced format**
```json
{
  "phone": {
    "type": "string",
    "pattern": "^\\+[1-9]\\d{1,14}$",
    "description": "Phone number in E.164 format (e.g., +14155552671). Must include country code."
  }
}
```

### Pattern 4: Nested Objects

```json
{
  "customer": {
    "type": "object",
    "description": "Customer information for the order",
    "properties": {
      "name": {
        "type": "string",
        "minLength": 1,
        "maxLength": 100
      },
      "email": {
        "type": "string",
        "format": "email",
        "description": "Customer's email address for order confirmation"
      },
      "shipping_address": {
        "type": "object",
        "properties": {
          "street": { "type": "string" },
          "city": { "type": "string" },
          "state": { "type": "string", "pattern": "^[A-Z]{2}$" },
          "zip": { "type": "string", "pattern": "^[0-9]{5}$" },
          "country": {
            "type": "string",
            "enum": ["US", "CA", "MX"],
            "description": "Two-letter ISO country code. Currently ship to US, Canada, and Mexico only."
          }
        },
        "required": ["street", "city", "state", "zip", "country"]
      }
    },
    "required": ["name", "email", "shipping_address"]
  }
}
```

### Pattern 5: Arrays with Item Schemas

```json
{
  "order_items": {
    "type": "array",
    "description": "List of products to order",
    "minItems": 1,
    "maxItems": 20,
    "items": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "pattern": "^SKU-[0-9]{5}$"
        },
        "quantity": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100
        }
      },
      "required": ["product_id", "quantity"]
    }
  }
}
```

---

## Complex Schema Examples

### Example 1: Support Ticket Creation

```typescript
const createTicketTool: Anthropic.Tool = {
  name: 'create_support_ticket',
  description: 'Create a customer support ticket. Use this when a customer reports a problem, asks for help, or expresses frustration. Do NOT use for general questions (use search_knowledge_base instead).',
  input_schema: {
    type: 'object',
    properties: {
      customer_email: {
        type: 'string',
        format: 'email',
        description: 'Customer\'s email address for follow-up'
      },
      subject: {
        type: 'string',
        minLength: 5,
        maxLength: 200,
        description: 'Brief summary of the issue (e.g., "Cannot log in to account")'
      },
      category: {
        type: 'string',
        enum: [
          'technical_issue',
          'billing_question',
          'feature_request',
          'account_access',
          'bug_report',
          'other'
        ],
        description: 'Issue category. Use "technical_issue" for broken features, "billing_question" for payment issues, "account_access" for login problems.'
      },
      priority: {
        type: 'string',
        enum: ['low', 'medium', 'high', 'urgent'],
        description: 'Urgency level. Use "urgent" if service is completely down or customer is very angry. Use "high" for broken core features. Use "medium" for minor issues. Use "low" for questions or feature requests.'
      },
      description: {
        type: 'string',
        minLength: 10,
        maxLength: 5000,
        description: 'Detailed description of the issue including error messages, steps to reproduce, and any relevant context.'
      },
      affected_features: {
        type: 'array',
        description: 'List of features or pages affected by this issue',
        items: {
          type: 'string',
          enum: ['login', 'dashboard', 'reports', 'api', 'mobile_app', 'billing', 'settings']
        }
      },
      customer_sentiment: {
        type: 'string',
        enum: ['satisfied', 'neutral', 'frustrated', 'angry'],
        description: 'Customer\'s emotional state based on their message tone'
      },
      metadata: {
        type: 'object',
        description: 'Additional context about the issue',
        properties: {
          browser: { type: 'string', description: 'Browser name and version if relevant' },
          os: { type: 'string', description: 'Operating system if relevant' },
          account_plan: {
            type: 'string',
            enum: ['free', 'pro', 'enterprise'],
            description: 'Customer\'s subscription tier'
          }
        }
      }
    },
    required: ['customer_email', 'subject', 'category', 'priority', 'description']
  }
}
```

### Example 2: Financial Transaction

```typescript
const transferFundsTool: Anthropic.Tool = {
  name: 'transfer_funds',
  description: 'Transfer money between accounts. CRITICAL: Only use when user explicitly requests a transfer with amount and accounts specified. Always confirm details before calling.',
  input_schema: {
    type: 'object',
    properties: {
      from_account: {
        type: 'string',
        pattern: '^[0-9]{10}$',
        description: '10-digit account number to transfer FROM'
      },
      to_account: {
        type: 'string',
        pattern: '^[0-9]{10}$',
        description: '10-digit account number to transfer TO'
      },
      amount: {
        type: 'number',
        minimum: 0.01,
        maximum: 100000,
        multipleOf: 0.01,
        description: 'Amount to transfer in USD. Maximum $100,000 per transaction.'
      },
      currency: {
        type: 'string',
        enum: ['USD', 'EUR', 'GBP', 'JPY'],
        default: 'USD',
        description: 'Currency code. Defaults to USD if not specified.'
      },
      memo: {
        type: 'string',
        maxLength: 200,
        description: 'Optional memo or description for the transfer'
      },
      schedule: {
        type: 'object',
        description: 'Optional: Schedule for future transfer. If not provided, transfer happens immediately.',
        properties: {
          date: {
            type: 'string',
            format: 'date',
            description: 'Date to execute transfer (YYYY-MM-DD). Must be today or future date.'
          },
          time: {
            type: 'string',
            pattern: '^([01][0-9]|2[0-3]):[0-5][0-9]$',
            description: 'Time to execute transfer in 24h format (HH:MM). Example: "14:30"'
          }
        },
        required: ['date']
      }
    },
    required: ['from_account', 'to_account', 'amount', 'currency']
  }
}
```

---

## Tool Catalog Organization

### Anti-pattern: Monolithic Tool

```typescript
// ❌ DON'T: One tool that does everything
{
  name: 'manage_inventory',
  description: 'Manage inventory',
  input_schema: {
    properties: {
      action: {
        type: 'string',
        enum: ['check', 'add', 'remove', 'transfer', 'audit']
      },
      // ... 20 more parameters for all possible actions
    }
  }
}
```

**Problems**:
- LLM confused about which parameters to use for which action
- Hard to maintain and evolve
- Poor error messages
- Difficult to version

### Best Practice: Specific Tools

```typescript
// ✅ DO: One tool per action
const inventoryTools: Anthropic.Tool[] = [
  {
    name: 'check_inventory',
    description: 'Check current stock level for a product at a specific warehouse. Use this when user asks "how many", "do we have", or "is X in stock".',
    input_schema: {
      type: 'object',
      properties: {
        product_id: { type: 'string', pattern: '^SKU-[0-9]{5}$' },
        warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] }
      },
      required: ['product_id', 'warehouse']
    }
  },
  {
    name: 'add_inventory',
    description: 'Record new inventory arriving at a warehouse. Use this when user says "received shipment" or "add stock". Requires manager permission.',
    input_schema: {
      type: 'object',
      properties: {
        product_id: { type: 'string', pattern: '^SKU-[0-9]{5}$' },
        warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] },
        quantity: { type: 'integer', minimum: 1, maximum: 10000 },
        po_number: { type: 'string', description: 'Purchase order number for audit trail' }
      },
      required: ['product_id', 'warehouse', 'quantity', 'po_number']
    }
  },
  {
    name: 'transfer_inventory',
    description: 'Move inventory between warehouses. Use when user says "move stock" or "transfer from X to Y".',
    input_schema: {
      type: 'object',
      properties: {
        product_id: { type: 'string', pattern: '^SKU-[0-9]{5}$' },
        from_warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] },
        to_warehouse: { type: 'string', enum: ['US_WEST', 'US_EAST', 'EU', 'ASIA'] },
        quantity: { type: 'integer', minimum: 1 }
      },
      required: ['product_id', 'from_warehouse', 'to_warehouse', 'quantity']
    }
  }
]
```

**Benefits**:
- ✅ Clear purpose for each tool
- ✅ Minimal parameters (no conditional logic)
- ✅ Easy to add new tools without breaking existing ones
- ✅ Better LLM tool selection accuracy

---

## Versioning & Evolution

### Problem: Breaking Changes

```typescript
// Version 1 (production)
{
  name: 'create_order',
  input_schema: {
    properties: {
      priority: { enum: ['standard', 'express'] }
    }
  }
}

// Version 2 (breaks existing behavior!)
{
  name: 'create_order',
  input_schema: {
    properties: {
      // ❌ BREAKING: removed 'express', added 'overnight'
      priority: { enum: ['standard', 'overnight'] }
    }
  }
}
```

### Solution: Versioned Tools

```typescript
// Old version (deprecated but still works)
{
  name: 'create_order_v1',
  description: '[DEPRECATED] Use create_order_v2 instead. This version will be removed on 2024-12-31.',
  input_schema: {
    properties: {
      priority: { enum: ['standard', 'express'] }
    }
  }
}

// New version
{
  name: 'create_order_v2',
  description: 'Create a product order [v2]. Replaces create_order_v1 with additional overnight shipping option.',
  input_schema: {
    properties: {
      priority: {
        enum: ['standard', 'express', 'overnight'],
        description: 'standard=5-7 days, express=2-3 days, overnight=next day'
      }
    }
  }
}
```

### Solution: Backwards-Compatible Changes

```typescript
// ✅ Safe: Add optional field
{
  name: 'create_order',
  input_schema: {
    properties: {
      priority: { enum: ['standard', 'express'] },
      gift_message: { type: 'string', description: 'Optional gift message' } // NEW
    }
  }
}

// ✅ Safe: Add new enum value (if it has sensible default)
{
  name: 'create_order',
  input_schema: {
    properties: {
      priority: {
        enum: ['standard', 'express', 'overnight'], // Added 'overnight'
        default: 'standard'
      }
    }
  }
}
```

---

## Testing Tool Specifications

```typescript
import { z } from 'zod'
import Anthropic from '@anthropic-ai/sdk'

// 1. Define expected behavior
const testCases = [
  {
    userMessage: 'What\'s the weather in London?',
    expectedTool: 'get_weather',
    expectedArgs: { location: 'London', unit: 'celsius' }
  },
  {
    userMessage: 'Ship 5 units of SKU-12345 to New York',
    expectedTool: 'create_shipment',
    expectedArgs: {
      product_id: 'SKU-12345',
      quantity: 5,
      destination: expect.stringContaining('New York')
    }
  },
  {
    userMessage: 'How much does overnight shipping cost?',
    expectedTool: 'calculate_shipping_cost',
    expectedArgs: { service_level: 'overnight' }
  }
]

// 2. Run tests
async function testToolSelection(testCase: typeof testCases[0]) {
  const response = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20240620',
    max_tokens: 1024,
    tools: allTools,
    messages: [{
      role: 'user',
      content: testCase.userMessage
    }]
  })

  // Check if LLM selected correct tool
  const toolUse = response.content.find(
    (block): block is Anthropic.ToolUseBlock => block.type === 'tool_use'
  )

  if (!toolUse) {
    throw new Error(`Expected tool use, got: ${response.stop_reason}`)
  }

  if (toolUse.name !== testCase.expectedTool) {
    throw new Error(
      `Expected tool ${testCase.expectedTool}, got ${toolUse.name}`
    )
  }

  // Validate arguments match schema
  const tool = allTools.find(t => t.name === testCase.expectedTool)!
  // ... validate toolUse.input against tool.input_schema

  console.log(`✅ Test passed: ${testCase.userMessage}`)
}

// 3. Run all tests
for (const testCase of testCases) {
  await testToolSelection(testCase)
}
```

---

## Production Checklist

Before deploying tools to production:

- [ ] **Clear descriptions** - Explain when to use AND when NOT to use
- [ ] **Enums for categorical data** - Never use free-form strings
- [ ] **Bounded numbers** - Set min/max for all numeric parameters
- [ ] **Regex patterns** - Enforce formats (phone, email, SKU, etc.)
- [ ] **Required fields** - Mark all mandatory parameters
- [ ] **Examples** - Include example values in descriptions
- [ ] **Nested validation** - Validate all levels of nested objects
- [ ] **Array constraints** - Set minItems/maxItems
- [ ] **Error messages** - Return helpful errors from tool functions
- [ ] **Versioning strategy** - Plan for evolving tools over time
- [ ] **Test coverage** - Test tool selection with realistic inputs
- [ ] **Authorization checks** - Validate permissions before execution
- [ ] **Observability** - Log all tool invocations
- [ ] **Documentation** - Document each tool's purpose and use cases

---

## Key Takeaways

### The Contract Mindset

> "You're not building an AI feature. You're designing an API contract where the client speaks natural language."

### Three Layers of Schema Design

1. **Structural** (JSON Schema) - Type, required, min/max
2. **Semantic** (Descriptions) - When to use, what values mean
3. **Operational** (Error handling) - What to do when things fail

### Common Mistakes

| Mistake | Impact | Solution |
|---------|--------|----------|
| Vague descriptions | LLM selects wrong tool | Explain when to use AND when NOT to use |
| No enums | LLM hallucinates values | Use enums for all categorical data |
| Unbounded numbers | Invalid values (999999) | Set realistic min/max |
| Generic tool names | Confusion between similar tools | Specific names (calculate_shipping_cost vs process) |
| Missing examples | LLM guesses format | Include example values |

### Why This Matters

**Bad schemas** → LLM confusion → Wrong tool selection → Production failures

**Good schemas** → Clear intent → Correct tool selection → Reliable system

**Schema design is not a nice-to-have. It's the foundation of reliable AI systems.**

---

## Next Steps

- [Week 4 Lab](../lab/support-ticket-router) - Build a Support Ticket Router with schema-driven tools
- [Week 5: AI Agents](../../week5/) - Chain tools to build autonomous agents
- [Week 7: Observability](../../week7/) - Monitor tool usage in production

---

## Further Reading

### Standards
- [JSON Schema Specification](https://json-schema.org/)
- [OpenAPI 3.0 Parameter Objects](https://swagger.io/specification/)

### Best Practices
- [Anthropic: Tool Use Best Practices](https://docs.anthropic.com/en/docs/build-with-claude/tool-use#best-practices-for-tool-definitions)
- [OpenAI: Function Calling Guide](https://platform.openai.com/docs/guides/function-calling)
- [Designing APIs for AI Agents](https://www.anthropic.com/research/building-effective-agents)
