---
title: "Automated Code Review Patterns"
description: "Build automated code review systems with AI"
estimatedMinutes: 40
---

# Automated Code Review Patterns

## What Makes a Good Code Review?

**Good reviews:**
- Constructive and specific
- Explain *why*, not just *what*
- Suggest improvements
- Catch real issues
- Respect developer time

**Bad reviews:**
- Nitpicky about style
- Vague feedback
- False positives
- Blockers on trivial issues

## Review Prompt Engineering

### Basic Review Prompt

```typescript
const REVIEW_PROMPT = `You are an expert code reviewer. Review this code for:

1. **Correctness**: Logic errors, edge cases
2. **Security**: Vulnerabilities, data validation
3. **Performance**: Inefficient algorithms, unnecessary operations
4. **Maintainability**: Code clarity, documentation
5. **Best Practices**: Language/framework conventions

For each issue:
- Severity: BLOCKER | MAJOR | MINOR | SUGGESTION
- Location: File + line number
- Description: What's wrong
- Suggestion: How to fix
- Explanation: Why it matters

Code to review:
{code}

Be constructive and specific. Prioritize significant issues.`
```

### Contextual Review

```typescript
async function reviewWithContext(
  diff: CodeDiff,
  context: ReviewContext
): Promise<Review> {
  const prompt = `Review this code change:

**Context:**
- File: ${diff.filePath}
- Author: ${context.author}
- Purpose: ${context.prDescription}
- Related files: ${context.relatedFiles.join(', ')}
- Framework: ${context.framework}
- Previous feedback: ${context.previousComments}

**Changes:**
\`\`\`diff
${diff.patch}
\`\`\`

**Original code:**
\`\`\`
${context.originalCode}
\`\`\`

Focus on:
1. Does this change achieve the stated purpose?
2. Are there unintended side effects?
3. Is error handling appropriate?
4. Are tests needed?
5. Breaking changes?

Be specific and reference line numbers.`

  const response = await claude.complete({ prompt })
  return parseReview(response)
}
```

## Review Categories

### Security Review

```typescript
async function securityReview(code: string): Promise<SecurityReview> {
  const response = await claude.complete({
    prompt: `Security review checklist:

**Input Validation:**
- [ ] All user inputs validated
- [ ] SQL injection prevention
- [ ] XSS prevention
- [ ] Path traversal prevention

**Authentication & Authorization:**
- [ ] Authentication required where needed
- [ ] Authorization checks present
- [ ] Session management secure

**Data Protection:**
- [ ] Sensitive data encrypted
- [ ] No hardcoded secrets
- [ ] PII handled properly

**Dependencies:**
- [ ] No known vulnerable dependencies
- [ ] Dependencies up to date

Code:
\`\`\`
${code}
\`\`\`

For each failed check, explain risk and fix.`
  })

  return parseSecurityReview(response)
}
```

### Performance Review

```typescript
async function performanceReview(code: string): Promise<PerformanceReview> {
  const response = await claude.complete({
    prompt: `Performance review:

**Check for:**
1. Algorithm complexity (is it O(nÂ²) or better?)
2. Unnecessary loops or iterations
3. Database query efficiency
4. Missing indexes
5. Memory leaks
6. Caching opportunities
7. Blocking operations

Code:
\`\`\`
${code}
\`\`\`

For each issue:
- Current complexity/impact
- Suggested optimization
- Expected improvement (e.g., "O(nÂ²) â†’ O(n log n)")
`
  })

  return parsePerformanceReview(response)
}
```

## Multi-Stage Review

```typescript
class CodeReviewer {
  async review(pr: PullRequest): Promise<ReviewResult> {
    const stages: ReviewStage[] = []

    // Stage 1: Quick checks
    stages.push(await this.quickChecks(pr))

    // Stage 2: Security scan
    if (stages[0].severity >= Severity.MAJOR) {
      stages.push(await this.securityScan(pr))
    }

    // Stage 3: Comprehensive review
    if (this.requiresDeepReview(pr)) {
      stages.push(await this.comprehensiveReview(pr))
    }

    // Stage 4: Test coverage check
    stages.push(await this.testCoverage Analysis(pr))

    return this.consolidate(stages)
  }

  private async quickChecks(pr: PullRequest): Promise<ReviewStage> {
    // Fast, cheap checks
    return {
      name: 'Quick Checks',
      issues: [
        ...await this.checkCodeStyle(pr),
        ...await this.checkFileSize(pr),
        ...await this.checkCommitMessages(pr)
      ]
    }
  }

  private async comprehensiveReview(pr: PullRequest): Promise<ReviewStage> {
    // Thorough AI review
    const files = await pr.getChangedFiles()

    const reviews = await Promise.all(
      files.map(f => reviewFile(f))
    )

    return {
      name: 'Comprehensive Review',
      issues: reviews.flat()
    }
  }
}
```

## Diff-Aware Reviewing

```typescript
async function reviewDiff(diff: string): Promise<DiffReview> {
  const response = await claude.complete({
    prompt: `Review this code diff:

\`\`\`diff
${diff}
\`\`\`

Focus ONLY on changed lines (+ additions, - deletions).

For each issue found:
1. Reference the exact line in the diff
2. Explain the problem
3. Suggest specific fix
4. Rate severity

Ignore:
- Style issues (use linters for that)
- Unchanged code (unless it provides context)
- Hypothetical issues not present in the diff`
  })

  return parseDiffReview(response)
}
```

## Comment Generation

### Inline Comments

```typescript
interface ReviewComment {
  file: string
  line: number
  message: string
  severity: Severity
  suggestion?: string
}

async function generateComments(review: Review): Promise<ReviewComment[]> {
  const comments: ReviewComment[] = []

  for (const issue of review.issues) {
    if (issue.severity >= Severity.MAJOR) {
      comments.push({
        file: issue.file,
        line: issue.line,
        message: formatComment(issue),
        severity: issue.severity,
        suggestion: issue.suggestedFix
      })
    }
  }

  return comments
}

function formatComment(issue: Issue): string {
  return `
**${issue.severity}**: ${issue.title}

${issue.description}

${issue.suggestion ? `**Suggested fix:**\n\`\`\`\n${issue.suggestion}\n\`\`\`\n` : ''}

**Why this matters:** ${issue.explanation}
`.trim()
}
```

### Summary Comment

```typescript
async function generateSummary(review: Review): Promise<string> {
  const blockers = review.issues.filter(i => i.severity === Severity.BLOCKER)
  const major = review.issues.filter(i => i.severity === Severity.MAJOR)
  const minor = review.issues.filter(i => i.severity === Severity.MINOR)

  return `
## Code Review Summary

**Status:** ${blockers.length > 0 ? 'âŒ Changes Required' : 'âœ… Looks Good'}

### Issues Found
- ðŸš« ${blockers.length} Blockers
- âš ï¸  ${major.length} Major
- â„¹ï¸  ${minor.length} Minor

${blockers.length > 0 ? `
### Blocking Issues
${blockers.map(formatIssue).join('\n\n')}
` : ''}

${major.length > 0 ? `
### Major Issues
${major.map(formatIssue).join('\n\n')}
` : ''}

### Overall Assessment
${await generateAssessment(review)}

---
*Powered by AI Code Review*
`.trim()
}
```

## GitHub Integration

```typescript
import { Octokit } from '@octokit/rest'

class GitHubReviewer {
  private octokit: Octokit

  constructor(token: string) {
    this.octokit = new Octokit({ auth: token })
  }

  async reviewPR(owner: string, repo: string, pullNumber: number) {
    // 1. Get PR files
    const { data: files } = await this.octokit.pulls.listFiles({
      owner,
      repo,
      pull_number: pullNumber
    })

    // 2. Review each file
    const reviews = await Promise.all(
      files.map(f => this.reviewFile(f))
    )

    // 3. Post comments
    for (const review of reviews.flat()) {
      await this.postComment(owner, repo, pullNumber, review)
    }

    // 4. Post summary
    const summary = await generateSummary(reviews.flat())
    await this.postSummaryComment(owner, repo, pullNumber, summary)

    // 5. Set review status
    await this.submitReview(owner, repo, pullNumber, reviews.flat())
  }

  private async postComment(
    owner: string,
    repo: string,
    pullNumber: number,
    comment: ReviewComment
  ) {
    await this.octokit.pulls.createReviewComment({
      owner,
      repo,
      pull_number: pullNumber,
      body: comment.message,
      path: comment.file,
      line: comment.line
    })
  }

  private async submitReview(
    owner: string,
    repo: string,
    pullNumber: number,
    issues: Issue[]
  ) {
    const hasBlockers = issues.some(i => i.severity === Severity.BLOCKER)

    await this.octokit.pulls.createReview({
      owner,
      repo,
      pull_number: pullNumber,
      event: hasBlockers ? 'REQUEST_CHANGES' : 'COMMENT'
    })
  }
}
```

## Smart Filtering

```typescript
async function filterRelevant(issues: Issue[]): Promise<Issue[]> {
  // Remove duplicates
  const unique = deduplicateIssues(issues)

  // Filter low-confidence issues
  const highConfidence = unique.filter(i => i.confidence > 0.8)

  // Remove issues already fixed in later commits
  const stillRelevant = await filterObsoleteIssues(highConfidence)

  // Group related issues
  const grouped = groupRelatedIssues(stillRelevant)

  return grouped
}

function deduplicateIssues(issues: Issue[]): Issue[] {
  const seen = new Set<string>()

  return issues.filter(issue => {
    const key = `${issue.file}:${issue.line}:${issue.type}`
    if (seen.has(key)) return false
    seen.add(key)
    return true
  })
}
```

## Learning from Feedback

```typescript
class LearningReviewer {
  private feedbackHistory: Feedback[] = []

  async review(code: string): Promise<Review> {
    const baseReview = await this.performReview(code)

    // Adjust based on past feedback
    const adjusted = this.adjustReview(baseReview)

    return adjusted
  }

  recordFeedback(reviewId: string, feedback: Feedback) {
    this.feedbackHistory.push({
      reviewId,
      ...feedback,
      timestamp: new Date()
    })
  }

  private adjustReview(review: Review): Review {
    // Learn from past false positives
    const falsePositives = this.feedbackHistory.filter(
      f => f.type === 'false_positive'
    )

    // Filter out similar issues
    return {
      ...review,
      issues: review.issues.filter(
        issue => !this.likelyFalsePositive(issue, falsePositives)
      )
    }
  }
}
```

## Best Practices

1. **Focus on significance**: Ignore trivial style issues
2. **Be constructive**: Always explain why and suggest fixes
3. **Provide context**: Include related code and files
4. **Validate suggestions**: Test fixes before proposing
5. **Learn from feedback**: Track false positives
6. **Respect time**: Don't block on minor issues
7. **Automate the boring**: Style, formatting, basic security

## Exercise

Build an automated reviewer:
1. Integrate with GitHub/GitLab
2. Review PRs automatically
3. Post inline comments
4. Generate summary reports
5. Track and learn from feedback

## Resources

- [GitHub Code Review Guide](https://github.com/features/code-review/)
- [Google Code Review Guidelines](https://google.github.io/eng-practices/review/)
- [Effective Code Reviews](https://stackoverflow.blog/2019/09/30/how-to-make-good-code-reviews-better/)
